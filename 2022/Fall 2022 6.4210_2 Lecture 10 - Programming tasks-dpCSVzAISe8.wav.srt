1
00:00:00,000 --> 00:00:10,000
 [BLANK_AUDIO]

2
00:00:10,000 --> 00:00:20,000
 [BLANK_AUDIO]

3
00:00:20,000 --> 00:00:30,000
 [BLANK_AUDIO]

4
00:00:30,000 --> 00:00:40,000
 [BLANK_AUDIO]

5
00:00:40,000 --> 00:00:50,000
 [BLANK_AUDIO]

6
00:00:50,000 --> 00:01:00,000
 [BLANK_AUDIO]

7
00:01:00,000 --> 00:01:10,000
 [BLANK_AUDIO]

8
00:01:10,000 --> 00:01:20,000
 [BLANK_AUDIO]

9
00:01:20,000 --> 00:01:30,000
 [BLANK_AUDIO]

10
00:01:30,000 --> 00:01:47,480
 [BLANK_AUDIO]

11
00:01:47,480 --> 00:01:57,480
 [BLANK_AUDIO]

12
00:01:57,480 --> 00:02:07,480
 [BLANK_AUDIO]

13
00:02:07,480 --> 00:02:17,480
 [BLANK_AUDIO]

14
00:02:17,480 --> 00:02:27,480
 [BLANK_AUDIO]

15
00:02:27,480 --> 00:02:37,480
 [BLANK_AUDIO]

16
00:02:37,480 --> 00:02:47,480
 [BLANK_AUDIO]

17
00:02:47,480 --> 00:02:57,480
 [BLANK_AUDIO]

18
00:02:57,480 --> 00:03:07,480
 [BLANK_AUDIO]

19
00:03:07,480 --> 00:03:17,480
 [BLANK_AUDIO]

20
00:03:17,480 --> 00:03:27,480
 [BLANK_AUDIO]

21
00:03:27,480 --> 00:03:37,480
 [BLANK_AUDIO]

22
00:03:37,480 --> 00:03:47,480
 [BLANK_AUDIO]

23
00:03:47,480 --> 00:03:57,480
 [BLANK_AUDIO]

24
00:03:57,480 --> 00:04:07,480
 [BLANK_AUDIO]

25
00:04:07,480 --> 00:04:17,480
 [BLANK_AUDIO]

26
00:04:17,480 --> 00:04:27,480
 [BLANK_AUDIO]

27
00:04:27,480 --> 00:04:37,480
 [BLANK_AUDIO]

28
00:04:37,480 --> 00:04:47,480
 [BLANK_AUDIO]

29
00:04:47,480 --> 00:04:57,480
 [BLANK_AUDIO]

30
00:04:57,480 --> 00:05:07,480
 [BLANK_AUDIO]

31
00:05:07,480 --> 00:05:17,480
 [BLANK_AUDIO]

32
00:05:17,480 --> 00:05:27,480
 [BLANK_AUDIO]

33
00:05:27,480 --> 00:05:37,480
 [BLANK_AUDIO]

34
00:05:37,480 --> 00:05:47,480
 [BLANK_AUDIO]

35
00:05:47,480 --> 00:05:57,480
 [BLANK_AUDIO]

36
00:05:57,480 --> 00:06:07,480
 [BLANK_AUDIO]

37
00:06:07,480 --> 00:06:17,480
 [BLANK_AUDIO]

38
00:06:17,480 --> 00:06:27,480
 [BLANK_AUDIO]

39
00:06:27,480 --> 00:06:37,480
 [BLANK_AUDIO]

40
00:06:37,480 --> 00:06:47,480
 [BLANK_AUDIO]

41
00:06:47,480 --> 00:06:57,480
 [BLANK_AUDIO]

42
00:06:57,480 --> 00:07:07,480
 [BLANK_AUDIO]

43
00:07:07,480 --> 00:07:17,480
 [BLANK_AUDIO]

44
00:07:17,480 --> 00:07:27,480
 [BLANK_AUDIO]

45
00:07:27,480 --> 00:07:37,480
 [BLANK_AUDIO]

46
00:07:37,480 --> 00:07:47,480
 [BLANK_AUDIO]

47
00:07:47,480 --> 00:07:57,480
 [BLANK_AUDIO]

48
00:07:57,480 --> 00:08:07,480
 [BLANK_AUDIO]

49
00:08:07,480 --> 00:08:17,480
 [BLANK_AUDIO]

50
00:08:17,480 --> 00:08:27,480
 [BLANK_AUDIO]

51
00:08:27,480 --> 00:08:30,480
 [BLANK_AUDIO]

52
00:08:30,480 --> 00:08:31,600
 OK.

53
00:08:31,600 --> 00:08:35,320
 So last time, I was drawing force diagrams.

54
00:08:35,320 --> 00:08:39,920
 I was trying to use my thumb coming out of the blackboard.

55
00:08:39,920 --> 00:08:45,200
 And I really wanted to have a little bit better picture for you.

56
00:08:45,200 --> 00:08:48,960
 So I went and made that over-- this is what I did with the long weekend.

57
00:08:48,960 --> 00:08:52,880
 And you also see the state machines I came up with, too.

58
00:08:52,880 --> 00:08:58,560
 But let me try again just to say the friction cone, force cone,

59
00:08:58,560 --> 00:09:02,080
 contact wrench story with a little bit better pictures.

60
00:09:02,080 --> 00:09:03,440
 OK?

61
00:09:03,440 --> 00:09:08,440
 So we talked about the forces.

62
00:09:08,440 --> 00:09:10,800
 I'm going to just do it on slides, because it's mostly

63
00:09:10,800 --> 00:09:12,560
 what I wrote on the board last time.

64
00:09:12,560 --> 00:09:16,880
 And it'll go faster if I don't write everything again.

65
00:09:16,880 --> 00:09:20,120
 But we talked a lot about forces.

66
00:09:20,120 --> 00:09:23,080
 And in general, the spatial force, the generalization,

67
00:09:23,080 --> 00:09:26,440
 is both a torque plus a force.

68
00:09:26,440 --> 00:09:30,920
 So we said torque plus a force.

69
00:09:30,920 --> 00:09:34,120
 This is applied at some point in space.

70
00:09:34,120 --> 00:09:34,800
 You can name it.

71
00:09:34,800 --> 00:09:38,520
 It can have an expressed in frame.

72
00:09:38,520 --> 00:09:40,720
 You can add them.

73
00:09:40,720 --> 00:09:45,320
 There's the spatial algebra of spatial forces, which sort of fits in.

74
00:09:45,320 --> 00:09:51,920
 But the most important one that came up was that there's this--

75
00:09:51,920 --> 00:09:56,120
 if you are considering a force applied on a body--

76
00:09:56,120 --> 00:10:04,120
 I'll draw just the simple version of this to foreshadow my animation here.

77
00:10:04,120 --> 00:10:10,120
 If I have a force being applied directly at a body, it's kind of weird.

78
00:10:10,120 --> 00:10:14,600
 You might think it's weird to think about how can I apply a torque.

79
00:10:14,600 --> 00:10:17,880
 That's not why the torques appear.

80
00:10:17,880 --> 00:10:20,600
 Maybe at every point that there's a force being applied,

81
00:10:20,600 --> 00:10:25,880
 it might be just a 3D force with no torque immediately.

82
00:10:25,880 --> 00:10:30,840
 But I can summarize the result of this force at any point on the body.

83
00:10:30,840 --> 00:10:34,080
 And if I want to think about its effect as if there was something applied

84
00:10:34,080 --> 00:10:38,720
 at this point on the body, then I can write this as a force plus a torque.

85
00:10:41,320 --> 00:10:45,280
 And if I want to think about the net effect of multiple forces applied

86
00:10:45,280 --> 00:10:50,040
 to multiple bodies, I can move them to the same point of reference,

87
00:10:50,040 --> 00:10:52,760
 sum them up.

88
00:10:52,760 --> 00:10:56,800
 So the way that you move between thinking about a particular force

89
00:10:56,800 --> 00:10:59,600
 being applied at a particular point on the body to a different point

90
00:10:59,600 --> 00:11:03,520
 on the body, the torques come from the cross product, which

91
00:11:03,520 --> 00:11:07,760
 is something you know from physics, from intro physics kind of stuff.

92
00:11:07,760 --> 00:11:10,720
 So the cross product of this vector with the force

93
00:11:10,720 --> 00:11:11,520
 gives me the torque.

94
00:11:11,520 --> 00:11:20,560
 And then we talked about-- please ask any questions if you have them.

95
00:11:20,560 --> 00:11:22,480
 I know I said that last time.

96
00:11:22,480 --> 00:11:26,400
 And then we drew these diagrams and we talked about the friction cone.

97
00:11:26,400 --> 00:11:28,880
 And I got a couple of good questions after just like,

98
00:11:28,880 --> 00:11:31,000
 what is going on with the cone?

99
00:11:31,000 --> 00:11:33,160
 Why is it not just one force?

100
00:11:33,160 --> 00:11:37,120
 Why can't the world decide and pick one force?

101
00:11:37,120 --> 00:11:41,040
 And the world will, of course, decide and pick one force.

102
00:11:41,040 --> 00:11:44,800
 But the laws of friction that we describe

103
00:11:44,800 --> 00:11:50,080
 are saying that friction will do whatever it needs to to resist motion,

104
00:11:50,080 --> 00:11:52,940
 but it'll pick one element from this set, which

105
00:11:52,940 --> 00:11:54,800
 is the range of possible forces.

106
00:11:54,800 --> 00:11:57,560
 They all live in that cone.

107
00:11:57,560 --> 00:12:00,160
 That's the way to think about this friction cone.

108
00:12:00,160 --> 00:12:04,720
 The rules of friction say, I will pick whatever force inside that cone that

109
00:12:04,720 --> 00:12:08,640
 will keep me from moving at all, relative to the point

110
00:12:08,640 --> 00:12:10,440
 that it's being applied.

111
00:12:10,440 --> 00:12:14,600
 And then if it is moving, it's just unable to completely stop motion.

112
00:12:14,600 --> 00:12:18,040
 It will dissipate energy as much as possible.

113
00:12:18,040 --> 00:12:22,280
 So as an abstraction, to think about the things that friction could do to me,

114
00:12:22,280 --> 00:12:26,720
 it's useful to think about a whole cone of possible forces.

115
00:12:26,720 --> 00:12:29,600
 And if I say there exists a force inside the cone,

116
00:12:29,600 --> 00:12:33,640
 then I know friction has the ability to stop my motion.

117
00:12:33,640 --> 00:12:36,160
 So it's a little bit weird to say, I'm not

118
00:12:36,160 --> 00:12:38,300
 picking a force right off the bat.

119
00:12:38,300 --> 00:12:41,000
 I'm going to think about all the things that friction could possibly

120
00:12:41,000 --> 00:12:44,080
 do in order to resist motion.

121
00:12:44,080 --> 00:12:45,640
 And that's what the friction cone is.

122
00:12:45,640 --> 00:12:53,160
 Get into my animation here.

123
00:12:53,160 --> 00:12:55,760
 So yeah, I guess I answered the check yourself.

124
00:12:55,760 --> 00:12:59,520
 That was a flub.

125
00:12:59,520 --> 00:13:01,640
 The interesting question then is, if you

126
00:13:01,640 --> 00:13:04,280
 think about the set of possible things that friction could

127
00:13:04,280 --> 00:13:07,360
 do to you to resist your motion, and you

128
00:13:07,360 --> 00:13:11,160
 think about the basic algebra of moving forces,

129
00:13:11,160 --> 00:13:14,320
 applying cross products, the algebra, given

130
00:13:14,320 --> 00:13:21,640
 that the points of contact are all fixed, is all linear operators.

131
00:13:21,640 --> 00:13:27,080
 These equations, if P is known, you're not moving the point of contact,

132
00:13:27,080 --> 00:13:30,360
 then the way that forces change through these equations

133
00:13:30,360 --> 00:13:34,240
 is always linear.

134
00:13:34,240 --> 00:13:39,760
 And if you replace a particular force with a whole cone,

135
00:13:39,760 --> 00:13:44,700
 and you ask how a matrix changes the cone, it turns out it stays a cone.

136
00:13:44,700 --> 00:13:47,400
 And that's the magic of what I was trying to talk about last time,

137
00:13:47,400 --> 00:13:50,720
 but I didn't have the animation to help me.

138
00:13:50,720 --> 00:13:56,040
 I didn't write this on the board last time,

139
00:13:56,040 --> 00:13:58,520
 but I'm putting it into the notes more carefully.

140
00:13:58,520 --> 00:14:04,720
 The point is that you can think about shifting-- so the friction cone,

141
00:14:04,720 --> 00:14:08,080
 right at the point of application, you might say there's no torsion.

142
00:14:08,080 --> 00:14:10,840
 There's no torque at the point of application.

143
00:14:10,840 --> 00:14:17,280
 And the cone at the point of application is defined by the xy components

144
00:14:17,280 --> 00:14:23,080
 in my contact frame being less than the coefficient of friction times

145
00:14:23,080 --> 00:14:24,080
 my z component.

146
00:14:24,080 --> 00:14:26,480
 That's what defined my cone.

147
00:14:26,480 --> 00:14:29,080
 That's just the friction cone definition.

148
00:14:29,080 --> 00:14:31,600
 If I want to shift that whole cone, if I

149
00:14:31,600 --> 00:14:37,800
 want to shift this whole cone of possibilities to here,

150
00:14:37,800 --> 00:14:45,120
 then I can apply my same linear operators of just shifting the force

151
00:14:45,120 --> 00:14:48,240
 and then getting a cross product to that whole cone.

152
00:14:48,240 --> 00:14:49,960
 And that's what I'm going to animate now.

153
00:14:53,120 --> 00:15:12,000
 So here's my little animation.

154
00:15:12,000 --> 00:15:14,160
 So I've got a box.

155
00:15:14,160 --> 00:15:15,040
 I'm not even gravity.

156
00:15:15,040 --> 00:15:18,080
 It's just a box stuck to the world.

157
00:15:18,080 --> 00:15:22,400
 And I'm applying a point on this box.

158
00:15:22,400 --> 00:15:25,760
 The green is the immediate friction cone.

159
00:15:25,760 --> 00:15:28,520
 And the red is the friction cone if I thought of it

160
00:15:28,520 --> 00:15:31,000
 from the point of-- as if the point of application

161
00:15:31,000 --> 00:15:33,360
 was the center of the body.

162
00:15:33,360 --> 00:15:35,360
 Is that clear?

163
00:15:35,360 --> 00:15:36,800
 Now here's the weird thing.

164
00:15:36,800 --> 00:15:44,280
 The friction cone has six elements.

165
00:15:44,280 --> 00:15:49,880
 So how do I animate a cone in six degrees of freedom?

166
00:15:49,880 --> 00:15:53,160
 I'm going to just cheat a little bit.

167
00:15:53,160 --> 00:15:55,740
 And there's a place where it's already going to be misleading.

168
00:15:55,740 --> 00:15:59,600
 I'm going to draw this cone, the 3xyz cone.

169
00:15:59,600 --> 00:16:04,000
 I'm also going to draw the torque cone as if it was independent,

170
00:16:04,000 --> 00:16:06,000
 but it's not actually independent.

171
00:16:06,000 --> 00:16:09,280
 So it's like the projection of the six-dimensional cone into two cones.

172
00:16:09,280 --> 00:16:11,240
 I think that'll be clear in my picture.

173
00:16:11,240 --> 00:16:13,600
 But that's what's happening is I'm going to draw two cones

174
00:16:13,600 --> 00:16:15,240
 to represent the six-dimensional space.

175
00:16:15,920 --> 00:16:18,320
 [AUDIO OUT]

176
00:16:18,320 --> 00:16:23,240
 OK.

177
00:16:23,240 --> 00:16:26,040
 And then I can move the body around.

178
00:16:26,040 --> 00:16:31,480
 And what you see here is that no matter where

179
00:16:31,480 --> 00:16:36,080
 I apply the forces on this body, I still

180
00:16:36,080 --> 00:16:39,840
 get the same xyz component of that force at the body.

181
00:16:39,840 --> 00:16:41,920
 That doesn't change.

182
00:16:41,920 --> 00:16:47,680
 What changes is the torsional component.

183
00:16:47,680 --> 00:16:49,920
 Depending on where I move around the body,

184
00:16:49,920 --> 00:16:54,800
 I get a different torque, a different wrench

185
00:16:54,800 --> 00:16:56,680
 that's representing my cone.

186
00:16:56,680 --> 00:16:59,440
 And it's a funny shape, right?

187
00:16:59,440 --> 00:17:03,660
 It's low dimensional.

188
00:17:03,660 --> 00:17:07,080
 You have to look at it from here to see what's happening.

189
00:17:07,080 --> 00:17:10,520
 Why is it low dimensional?

190
00:17:10,520 --> 00:17:12,600
 Well, we know every element in that set

191
00:17:12,600 --> 00:17:15,760
 has to be orthogonal to the cross product.

192
00:17:15,760 --> 00:17:19,960
 It has to be orthogonal to the line from here to here.

193
00:17:19,960 --> 00:17:27,000
 You can't produce torque except for orthogonal to that line.

194
00:17:27,000 --> 00:17:34,160
 And as I move further away, I'll get this elongated cone.

195
00:17:34,160 --> 00:17:35,600
 I'm drawing a truncated cone.

196
00:17:35,600 --> 00:17:37,840
 The real cone, if there's no limits,

197
00:17:37,840 --> 00:17:41,920
 would go on forever, but in those directions.

198
00:17:41,920 --> 00:17:45,680
 Does that picture help at all?

199
00:17:45,680 --> 00:17:46,180
 Oh, man.

200
00:17:46,180 --> 00:17:50,640
 Does that picture help at all?

201
00:17:50,640 --> 00:17:54,760
 So why is it torque over here now?

202
00:17:54,760 --> 00:17:58,480
 Is that if I am applying a force that goes here,

203
00:17:58,480 --> 00:18:02,560
 then my friction cone should be in--

204
00:18:02,560 --> 00:18:04,520
 did I get the right direction?

205
00:18:04,520 --> 00:18:06,320
 Did I get the right direction?

206
00:18:06,320 --> 00:18:10,400
 I can only resist motion in one axis.

207
00:18:10,400 --> 00:18:12,840
 So I resist motion like that.

208
00:18:12,840 --> 00:18:18,320
 Yes?

209
00:18:18,320 --> 00:18:22,640
 [INAUDIBLE]

210
00:18:22,640 --> 00:18:23,440
 That's correct.

211
00:18:23,440 --> 00:18:27,560
 So if I were to come up to this body and apply a perturbation,

212
00:18:27,560 --> 00:18:31,920
 and you ask what can that frictional force resist,

213
00:18:31,920 --> 00:18:35,520
 if the perturbation torque I applied is inside that cone,

214
00:18:35,520 --> 00:18:38,840
 then friction can stop me.

215
00:18:38,840 --> 00:18:43,160
 So if I apply a torque that's pushing me into the finger,

216
00:18:43,160 --> 00:18:44,360
 it can stop me.

217
00:18:44,360 --> 00:18:45,840
 But there's a whole other direction.

218
00:18:45,840 --> 00:18:47,200
 If I apply the torque in the other direction,

219
00:18:47,200 --> 00:18:48,560
 where I'm just going to move away from the finger,

220
00:18:48,560 --> 00:18:49,600
 the finger won't stop me.

221
00:18:49,600 --> 00:18:50,680
 That's why it's one-sided.

222
00:18:50,680 --> 00:18:57,720
 The point I wanted to make last time

223
00:18:57,720 --> 00:19:01,680
 was that the antipodal grasping is a good strategy.

224
00:19:01,680 --> 00:19:05,360
 I think with this picture I can land that idea.

225
00:19:05,360 --> 00:19:08,120
 I'm not as confident now as I was a few minutes ago,

226
00:19:08,120 --> 00:19:11,960
 but let's try.

227
00:19:11,960 --> 00:19:18,120
 I need a second finger.

228
00:19:18,120 --> 00:19:24,760
 OK, two fingers now.

229
00:19:24,760 --> 00:19:25,760
 I can move them around.

230
00:19:25,760 --> 00:19:34,540
 If they're down here, what happens

231
00:19:34,540 --> 00:19:37,080
 is that the friction, the torsional effect

232
00:19:37,080 --> 00:19:39,640
 that that friction can have, they're

233
00:19:39,640 --> 00:19:42,320
 both in the same direction, right?

234
00:19:42,320 --> 00:19:44,600
 There's a whole motion that I can't resist whatsoever.

235
00:19:44,600 --> 00:19:52,240
 But if I move it up, and I'm more antipodal,

236
00:19:52,240 --> 00:19:53,640
 then something beautiful happens.

237
00:19:53,640 --> 00:20:00,700
 So not only are they going in opposite directions.

238
00:20:00,700 --> 00:20:02,280
 That's good.

239
00:20:02,280 --> 00:20:07,520
 But because they're coming from a different cross product,

240
00:20:07,520 --> 00:20:11,920
 they span a different space.

241
00:20:11,920 --> 00:20:15,520
 So this one can accommodate wrenches

242
00:20:15,520 --> 00:20:17,560
 that are in that plane.

243
00:20:17,560 --> 00:20:19,100
 And this one can accommodate wrenches

244
00:20:19,100 --> 00:20:20,060
 that are in that plane.

245
00:20:20,060 --> 00:20:23,400
 It makes a nice little butterfly kind of looking thing.

246
00:20:28,320 --> 00:20:32,520
 The rules of now saying, can I find

247
00:20:32,520 --> 00:20:37,280
 something that resists me in either of those forces

248
00:20:37,280 --> 00:20:41,200
 are using what's called the Minkowski sum.

249
00:20:41,200 --> 00:20:45,880
 If you try to ask, if I apply a new wrench,

250
00:20:45,880 --> 00:20:49,880
 can the sum of the two wrenches resist my motion,

251
00:20:49,880 --> 00:20:53,800
 then that's equivalent to asking if the wrench is

252
00:20:53,800 --> 00:20:56,120
 in the Minkowski sum of those two.

253
00:20:56,120 --> 00:20:58,360
 And now that these are spanning the space,

254
00:20:58,360 --> 00:21:01,600
 I have a nice strong wrench that I can resist with.

255
00:21:01,600 --> 00:21:08,720
 So maybe you're totally on board now.

256
00:21:08,720 --> 00:21:10,400
 That would be awesome.

257
00:21:10,400 --> 00:21:13,920
 But at very least, when things line up, they look pretty--

258
00:21:13,920 --> 00:21:17,600
 right, I mean, they look like they're covering a lot of space.

259
00:21:17,600 --> 00:21:18,720
 It's an effective grasp.

260
00:21:18,720 --> 00:21:23,680
 And it's different if I move them off to the side.

261
00:21:23,680 --> 00:21:27,600
 But the story is still sort of the same.

262
00:21:27,600 --> 00:21:33,560
 So as a general strategy, if all things are created equal,

263
00:21:33,560 --> 00:21:36,000
 I'd like to be nicely aligned around the center of mass,

264
00:21:36,000 --> 00:21:38,200
 because then there's no gravitational torque

265
00:21:38,200 --> 00:21:39,400
 to resist whatsoever.

266
00:21:39,400 --> 00:21:42,720
 And I only have to worry about external forces.

267
00:21:42,720 --> 00:21:45,420
 But if I don't know much about the object, what we did last

268
00:21:45,420 --> 00:21:47,360
 time was we said, let's just go ahead and just

269
00:21:47,360 --> 00:21:49,320
 pick antipodal grasps.

270
00:21:49,320 --> 00:21:52,200
 Because without knowing more, that's a pretty good strategy.

271
00:21:52,200 --> 00:21:53,040
 Yeah?

272
00:21:53,040 --> 00:21:57,000
 So because of the Minkowski sum thing,

273
00:21:57,000 --> 00:21:58,960
 that's like the one blue thing dragged

274
00:21:58,960 --> 00:22:00,400
 across the other blue thing.

275
00:22:00,400 --> 00:22:01,040
 Exactly.

276
00:22:01,040 --> 00:22:04,520
 Does that create-- does that fill the whole 3D space

277
00:22:04,520 --> 00:22:06,680
 all around it so it can resist everything?

278
00:22:06,680 --> 00:22:08,000
 That's what I want.

279
00:22:08,000 --> 00:22:09,160
 That's the picture I want.

280
00:22:09,160 --> 00:22:11,640
 The details are just a little bit more subtle.

281
00:22:11,640 --> 00:22:14,240
 So the question was-- let me repeat.

282
00:22:14,240 --> 00:22:17,040
 So the Minkowski sum you should think about

283
00:22:17,040 --> 00:22:20,680
 as taking one element from the first set

284
00:22:20,680 --> 00:22:22,520
 and then applying the entire second set

285
00:22:22,520 --> 00:22:24,360
 to every element of the first set.

286
00:22:24,360 --> 00:22:26,880
 So it's like you can drag it around.

287
00:22:26,880 --> 00:22:30,520
 So take this cone here and apply it

288
00:22:30,520 --> 00:22:34,120
 to every possible force in there.

289
00:22:34,120 --> 00:22:36,160
 And so yes, it looks, from this picture,

290
00:22:36,160 --> 00:22:38,700
 like you can create the whole space.

291
00:22:38,700 --> 00:22:40,600
 The only thing that's a little bit misleading

292
00:22:40,600 --> 00:22:43,800
 is because I've done the projection of the two--

293
00:22:43,800 --> 00:22:45,880
 of the six-dimensional space under the 3D,

294
00:22:45,880 --> 00:22:50,200
 you don't get to independently pick x, y, z and torque.

295
00:22:50,200 --> 00:22:52,800
 So you have to be a little bit more careful about saying that.

296
00:22:52,800 --> 00:22:54,640
 But to first order, absolutely, the picture

297
00:22:54,640 --> 00:22:57,040
 I want you to have is that the Minkowski sum of that

298
00:22:57,040 --> 00:23:00,000
 resists all torques.

299
00:23:00,000 --> 00:23:01,000
 Yeah?

300
00:23:01,000 --> 00:23:01,720
 Pure torques.

301
00:23:01,720 --> 00:23:04,120
 I can say with confidence right from this picture,

302
00:23:04,120 --> 00:23:07,080
 you can resist pure torques, all pure torques.

303
00:23:07,080 --> 00:23:07,580
 Yes?

304
00:23:07,580 --> 00:23:10,520
 So that's even in the torque if it was like the two points

305
00:23:10,520 --> 00:23:12,720
 like this and then it was this way.

306
00:23:12,720 --> 00:23:13,720
 Right.

307
00:23:13,720 --> 00:23:16,200
 So think about how that would happen.

308
00:23:16,200 --> 00:23:20,560
 So the reason that you can produce arbitrarily large,

309
00:23:20,560 --> 00:23:22,120
 it's a function of your normal force.

310
00:23:22,120 --> 00:23:24,840
 It means you'd have to squeeze harder.

311
00:23:24,840 --> 00:23:26,480
 But if you're willing to squeeze harder,

312
00:23:26,480 --> 00:23:29,200
 then under this friction law, you

313
00:23:29,200 --> 00:23:31,080
 can resist all of those torques.

314
00:23:31,080 --> 00:23:39,460
 Yes?

315
00:23:39,460 --> 00:23:41,640
 Sorry, could we see the case again

316
00:23:41,640 --> 00:23:42,920
 where they're not antithetical?

317
00:23:42,920 --> 00:23:43,420
 Yeah.

318
00:23:43,420 --> 00:23:43,920
 Yeah.

319
00:23:43,920 --> 00:23:53,780
 I think the difference about spanning space is not--

320
00:23:53,780 --> 00:23:59,860
 I think the coupling becomes more important.

321
00:23:59,860 --> 00:24:06,540
 I think the optimality of antipodal grasps maybe

322
00:24:06,540 --> 00:24:13,260
 isn't completely visible in this projection.

323
00:24:13,260 --> 00:24:15,780
 If you think about only spanning the spaces.

324
00:24:15,780 --> 00:24:17,540
 But maybe the magnitude already tells you

325
00:24:17,540 --> 00:24:18,860
 something that it could be good.

326
00:24:18,860 --> 00:24:31,340
 OK.

327
00:24:31,340 --> 00:24:34,100
 It's a little better maybe, but that's this wrench

328
00:24:34,100 --> 00:24:35,100
 visualization.

329
00:24:35,100 --> 00:24:36,780
 You can play with it.

330
00:24:36,780 --> 00:24:38,660
 I pushed it to the deep note.

331
00:24:38,660 --> 00:24:42,980
 So you can play with that and tell me if it makes sense

332
00:24:42,980 --> 00:24:44,140
 or doesn't make sense.

333
00:24:44,140 --> 00:24:46,980
 I want to hear if it was worth it.

334
00:24:46,980 --> 00:24:48,980
 There was a weird--

335
00:24:48,980 --> 00:24:50,940
 I spent way too much time making this animation.

336
00:24:50,940 --> 00:24:53,500
 Because there was a bug in--

337
00:24:53,500 --> 00:24:56,180
 or not a bug, but a known limitation in the way

338
00:24:56,180 --> 00:25:01,500
 the WebGL works in the browser.

339
00:25:01,500 --> 00:25:03,940
 I was sure that my math was wrong for hours.

340
00:25:03,940 --> 00:25:08,460
 And then it was not my fault directly.

341
00:25:08,460 --> 00:25:08,960
 Anyways.

342
00:25:08,960 --> 00:25:18,560
 So you better have learned something from that.

343
00:25:18,560 --> 00:25:19,060
 OK.

344
00:25:19,060 --> 00:25:22,640
 And the Minkowski sum is sort of the beautiful part of that.

345
00:25:22,640 --> 00:25:26,140
 OK.

346
00:25:26,140 --> 00:25:33,080
 So let me tell you now about back to the clutter clearing.

347
00:25:33,080 --> 00:25:36,880
 So we were talking about this project

348
00:25:36,880 --> 00:25:38,840
 with the robot moving things back and forth.

349
00:25:38,840 --> 00:25:40,800
 That's kind of our short-term goal.

350
00:25:40,800 --> 00:25:42,920
 You should be able to program a robot

351
00:25:42,920 --> 00:25:46,600
 to do stuff like this with no knowledge of the objects,

352
00:25:46,600 --> 00:25:50,680
 with dense clutter, and to do its thing.

353
00:25:50,680 --> 00:25:52,600
 So that's the other thing I did.

354
00:25:52,600 --> 00:25:55,400
 Hopefully it'll load in a reasonable amount of time here.

355
00:25:55,400 --> 00:25:56,940
 As I finished that example, remember

356
00:25:56,940 --> 00:25:58,600
 how I showed you my halfway example

357
00:25:58,600 --> 00:26:01,100
 and it ran directly into the camera and it dropped the thing

358
00:26:01,100 --> 00:26:02,140
 and you guys all laughed.

359
00:26:05,320 --> 00:26:06,440
 We made a big file.

360
00:26:06,440 --> 00:26:18,000
 So let me-- I can run it locally too.

361
00:26:18,000 --> 00:26:36,280
 [SIGHS]

362
00:26:36,280 --> 00:26:38,880
 OK, I'll run it locally instead.

363
00:26:38,880 --> 00:26:40,400
 It's taking a long time to load.

364
00:26:40,400 --> 00:26:45,960
 I made a big file, partly because I replaced the red

365
00:26:45,960 --> 00:26:48,280
 bricks with other YCB objects.

366
00:26:48,280 --> 00:26:50,480
 I thought that would be a little bit more interesting.

367
00:26:50,480 --> 00:26:54,600
 But those stupid meshes are so big-- or the texture maps

368
00:26:54,600 --> 00:26:56,440
 are so big that it takes a long time for it

369
00:26:56,440 --> 00:27:00,000
 to come in the browser when I'm in campus Wi-Fi.

370
00:27:00,000 --> 00:27:08,560
 OK, here goes.

371
00:27:08,560 --> 00:27:12,160
 Random YCB objects thrown in a bin.

372
00:27:12,160 --> 00:27:15,480
 Now it's going to start-- it's going to do our whole pipeline.

373
00:27:15,480 --> 00:27:18,240
 So there's cameras here.

374
00:27:18,240 --> 00:27:20,520
 They are going to do the point cloud processing.

375
00:27:20,520 --> 00:27:22,880
 It actually waited for a second for the initial conditions

376
00:27:22,880 --> 00:27:24,480
 to fall.

377
00:27:24,480 --> 00:27:26,400
 It's going to then take the point clouds,

378
00:27:26,400 --> 00:27:30,760
 do some point cloud processing, find the normals,

379
00:27:30,760 --> 00:27:33,840
 take random samples, do the antipodal grasp, the grasp

380
00:27:33,840 --> 00:27:34,640
 selection.

381
00:27:34,640 --> 00:27:36,920
 It tries 100 random grasps.

382
00:27:36,920 --> 00:27:40,640
 It picks the best one by our little grasp metric.

383
00:27:40,640 --> 00:27:43,720
 And then it does everything we've talked about so far.

384
00:27:43,720 --> 00:27:46,360
 It makes a simple plan of the gripper frames.

385
00:27:46,360 --> 00:27:49,840
 It interpolates that into a piecewise pose trajectory.

386
00:27:49,840 --> 00:27:51,920
 It then runs differential IK.

387
00:27:51,920 --> 00:27:54,400
 This is the whole tool chain.

388
00:27:54,400 --> 00:27:55,800
 And it's going to do its thing.

389
00:27:55,800 --> 00:28:00,280
 It's going to pick up and slowly move all the objects.

390
00:28:00,280 --> 00:28:04,520
 It will still fail every once in a while, but it's pretty good.

391
00:28:04,520 --> 00:28:06,680
 And actually, the failures are to the point

392
00:28:06,680 --> 00:28:13,200
 now where I think they're pedagogically interesting.

393
00:28:13,200 --> 00:28:15,480
 It's not like I didn't spend enough time with the code.

394
00:28:15,480 --> 00:28:17,880
 It's like we haven't done motion planning yet.

395
00:28:17,880 --> 00:28:22,520
 And so we need a better tool for this.

396
00:28:22,520 --> 00:28:24,560
 And this will go all day long.

397
00:28:24,560 --> 00:28:25,940
 Every time you run it, it'll have

398
00:28:25,940 --> 00:28:27,400
 different initial conditions.

399
00:28:27,400 --> 00:28:30,280
 It also has some fairly-- not sophisticated,

400
00:28:30,280 --> 00:28:37,120
 but the basic-- that's awesome-- some basic recovery maneuvers.

401
00:28:37,120 --> 00:28:38,560
 So sometimes it'll pick-- remember,

402
00:28:38,560 --> 00:28:40,880
 the antipodal grasps are just a heuristic.

403
00:28:40,880 --> 00:28:43,200
 Sometimes it'll pick right on the edge of a soup

404
00:28:43,200 --> 00:28:44,440
 can or something like this.

405
00:28:44,440 --> 00:28:46,880
 And see, that was a double pick that it

406
00:28:46,880 --> 00:28:48,840
 started to do right there.

407
00:28:48,840 --> 00:28:49,400
 It rotated.

408
00:28:49,400 --> 00:28:51,120
 It didn't drop this one.

409
00:28:51,120 --> 00:28:54,120
 But if it does fail to grasp, it'll lift up.

410
00:28:54,120 --> 00:28:55,560
 It'll realize it failed to grasp.

411
00:28:55,560 --> 00:28:58,280
 It'll go back down.

412
00:28:58,280 --> 00:29:01,120
 It also, when it can't find a grasp--

413
00:29:01,120 --> 00:29:02,580
 I'm going to write all of this down.

414
00:29:02,580 --> 00:29:04,920
 When it can't find the grasp in the first bin,

415
00:29:04,920 --> 00:29:07,480
 it'll transition to the second bin

416
00:29:07,480 --> 00:29:10,840
 and start picking from the other bin out.

417
00:29:10,840 --> 00:29:12,920
 See, look, it stopped.

418
00:29:12,920 --> 00:29:14,320
 And it realized that it did that.

419
00:29:14,320 --> 00:29:17,640
 And it's going back to pick a different thing.

420
00:29:17,640 --> 00:29:20,640
 That extra level of robustness makes this something that--

421
00:29:20,640 --> 00:29:23,240
 [LAUGHTER]

422
00:29:23,240 --> 00:29:24,040
 But it knew it.

423
00:29:24,040 --> 00:29:25,880
 See, it realized it, I think.

424
00:29:25,880 --> 00:29:27,240
 Yeah, come on.

425
00:29:27,240 --> 00:29:28,720
 And try it again.

426
00:29:28,720 --> 00:29:31,220
 See, that was one where I was like, you know, that failed.

427
00:29:31,220 --> 00:29:33,920
 That's a lesson.

428
00:29:33,920 --> 00:29:35,840
 And it'll keep going to the point

429
00:29:35,840 --> 00:29:37,720
 where I just let it run at night.

430
00:29:37,720 --> 00:29:38,400
 And I came back.

431
00:29:38,400 --> 00:29:40,480
 And the funny thing was, all the little things

432
00:29:40,480 --> 00:29:42,240
 you do to make it robust-- so for instance,

433
00:29:42,240 --> 00:29:44,880
 I actually put an invisible floor underneath there.

434
00:29:44,880 --> 00:29:45,960
 Why?

435
00:29:45,960 --> 00:29:48,080
 Because it every once in a while does drop objects,

436
00:29:48,080 --> 00:29:50,120
 just like the real robot did.

437
00:29:50,120 --> 00:29:52,640
 And if they fall to negative infinity,

438
00:29:52,640 --> 00:29:55,200
 then it makes my contact solver fail,

439
00:29:55,200 --> 00:29:58,040
 because that's numerically bad to have a negative infinity

440
00:29:58,040 --> 00:30:00,040
 and a number around 0.

441
00:30:00,040 --> 00:30:01,480
 So now there's a floor.

442
00:30:01,480 --> 00:30:04,920
 And they can only fall to like 1 meter.

443
00:30:04,920 --> 00:30:07,480
 And then because there's soup cans,

444
00:30:07,480 --> 00:30:09,240
 I had to put lips on the floor.

445
00:30:09,240 --> 00:30:10,360
 Because they would fall to the floor.

446
00:30:10,360 --> 00:30:11,680
 And they would roll off the side and then

447
00:30:11,680 --> 00:30:13,400
 fall to negative infinity.

448
00:30:13,400 --> 00:30:15,640
 So all the little things got figured out.

449
00:30:15,640 --> 00:30:17,280
 And now it just will run all night.

450
00:30:17,280 --> 00:30:19,920
 And with some probability, depending

451
00:30:19,920 --> 00:30:21,640
 on how long you sleep, it'll come back.

452
00:30:21,640 --> 00:30:24,320
 And many of the things will be on the floor.

453
00:30:24,320 --> 00:30:25,160
 But it didn't crash.

454
00:30:25,160 --> 00:30:28,960
 And it kept going and does its thing.

455
00:30:28,960 --> 00:30:31,880
 The other interesting one that maybe I kind of hope we see,

456
00:30:31,880 --> 00:30:34,200
 but I have mixed feelings about, is

457
00:30:34,200 --> 00:30:38,720
 that differential IK can get itself in a bad state.

458
00:30:38,720 --> 00:30:41,840
 Yeah, you see, it didn't try to grasp there.

459
00:30:41,840 --> 00:30:48,080
 But the hand is unable to get where it's trying to grasp.

460
00:30:48,080 --> 00:30:51,240
 Because the differential IK is commanding a certain thing.

461
00:30:51,240 --> 00:30:53,000
 It's getting a certain different thing.

462
00:30:53,000 --> 00:30:55,480
 But look, it's going to try, I think, five times.

463
00:30:55,480 --> 00:30:58,480
 And then it'll give up and say, I'm done with this bin.

464
00:30:58,480 --> 00:31:00,840
 I'm going to go do the other bin.

465
00:31:00,840 --> 00:31:01,800
 That was even worse.

466
00:31:08,240 --> 00:31:09,240
 Is that five?

467
00:31:09,240 --> 00:31:15,680
 Maybe this is five.

468
00:31:15,680 --> 00:31:26,440
 See?

469
00:31:26,440 --> 00:31:27,980
 That's like intelligence right there.

470
00:31:27,980 --> 00:31:33,600
 OK, yeah, and so there is one other super interesting thing

471
00:31:33,600 --> 00:31:38,480
 it does, which is that sometimes differential IK will actually--

472
00:31:38,480 --> 00:31:40,960
 because it's not thinking about the joint constraints

473
00:31:40,960 --> 00:31:42,240
 of the robot.

474
00:31:42,240 --> 00:31:44,820
 It could choose a trajectory that goes very close to the base.

475
00:31:44,820 --> 00:31:47,120
 And then the arm starts kind of getting a little funky.

476
00:31:47,120 --> 00:31:50,920
 And the Jacobian, it'll get itself kind of tangled up

477
00:31:50,920 --> 00:31:52,800
 with just a differential IK view of the world.

478
00:31:52,800 --> 00:31:53,680
 Because it hasn't thought of anything

479
00:31:53,680 --> 00:31:55,280
 about the joint constraints of the robot.

480
00:31:55,280 --> 00:31:57,700
 It's just thinking about moving a hand through the world.

481
00:31:57,700 --> 00:32:01,160
 And that's an impoverished view of what the robot has to do.

482
00:32:01,160 --> 00:32:03,500
 So the last thing I had to do to make

483
00:32:03,500 --> 00:32:05,840
 it sort of nice and robust is that if it got itself

484
00:32:05,840 --> 00:32:09,920
 all tangled up, and if the tracking error of the hand

485
00:32:09,920 --> 00:32:12,600
 compared to the commanded hand got large,

486
00:32:12,600 --> 00:32:14,120
 then it would say, OK, I give up.

487
00:32:14,120 --> 00:32:15,160
 And it would switch.

488
00:32:15,160 --> 00:32:17,360
 It would turn off differential IK,

489
00:32:17,360 --> 00:32:19,760
 turn on just joint control mode, and just go,

490
00:32:19,760 --> 00:32:22,320
 you know what, I'm going to come back to my comfortable home

491
00:32:22,320 --> 00:32:24,800
 position, and I'll start again.

492
00:32:24,800 --> 00:32:26,440
 Things got bad.

493
00:32:26,440 --> 00:32:29,040
 I've got a safe space, and I'll come back in again.

494
00:32:29,040 --> 00:32:29,540
 Yes?

495
00:32:29,540 --> 00:32:32,520
 So in, like, I don't know, those manipulation papers

496
00:32:32,520 --> 00:32:34,320
 and things like that, when you have, like,

497
00:32:34,320 --> 00:32:35,920
 a video showing double results, there

498
00:32:35,920 --> 00:32:38,400
 will tend to be, like, a 10x speed thing.

499
00:32:38,400 --> 00:32:41,400
 So what kind of step in the whole process

500
00:32:41,400 --> 00:32:43,720
 is the sort of time-consuming?

501
00:32:43,720 --> 00:32:46,100
 This is all running in real time right now on my computer,

502
00:32:46,100 --> 00:32:47,480
 on this laptop.

503
00:32:47,480 --> 00:32:49,480
 Yeah, so that's 1x right now.

504
00:32:49,480 --> 00:32:52,440
 So like, when you're, like, putting this on a real robot,

505
00:32:52,440 --> 00:32:54,280
 would it be like that speed?

506
00:32:54,280 --> 00:32:56,600
 The only thing that would be different on the real robot

507
00:32:56,600 --> 00:32:59,440
 would be that physics would definitely run at real speed.

508
00:32:59,440 --> 00:33:03,280
 And so, yeah, this is just running at real time speed.

509
00:33:03,280 --> 00:33:04,280
 Yeah?

510
00:33:04,280 --> 00:33:09,160
 I mean, the limitations of the motion planning

511
00:33:09,160 --> 00:33:10,460
 are partly because it's simple.

512
00:33:10,460 --> 00:33:12,480
 I could spend more time making motion plans,

513
00:33:12,480 --> 00:33:14,820
 and then you might see the famous robot pauses,

514
00:33:14,820 --> 00:33:17,240
 where it stops to think about a motion plan and then moves,

515
00:33:17,240 --> 00:33:19,440
 which the community is getting better at,

516
00:33:19,440 --> 00:33:21,800
 and we should aspire to not have.

517
00:33:21,800 --> 00:33:25,760
 But there's no pause--

518
00:33:25,760 --> 00:33:27,760
 OK, the one little thing that cheats here

519
00:33:27,760 --> 00:33:32,000
 is that the simulation clock can stop while I think

520
00:33:32,000 --> 00:33:34,560
 in this version of the simulation.

521
00:33:34,560 --> 00:33:35,880
 But you would see that.

522
00:33:35,880 --> 00:33:38,880
 If it looks like it's frozen, and even the physics

523
00:33:38,880 --> 00:33:41,360
 is frozen, that's because it was thinking for a long time.

524
00:33:41,360 --> 00:33:45,200
 But I don't think there's any computation that's really--

525
00:33:45,200 --> 00:33:48,080
 and I'm simulating at a pretty conservative simulation DT,

526
00:33:48,080 --> 00:33:51,680
 just because I wanted to not have anything--

527
00:33:51,680 --> 00:33:52,600
 it can crash.

528
00:33:52,600 --> 00:33:55,000
 I will list down the failure modes in a little bit.

529
00:33:55,000 --> 00:33:56,420
 It can crash, but only really--

530
00:33:56,420 --> 00:33:58,540
 I've only seen it crash at the initial conditions.

531
00:33:58,540 --> 00:34:00,880
 If I-- my random initial bin thing

532
00:34:00,880 --> 00:34:05,520
 put things in deep penetration, it could potentially blow up.

533
00:34:05,520 --> 00:34:08,520
 So on a real robot, what is the--

534
00:34:08,520 --> 00:34:11,480
 on actual hardware, what is the bottleneck for the speed?

535
00:34:11,480 --> 00:34:13,480
 Is it the motion planning in this case?

536
00:34:13,480 --> 00:34:16,840
 Like, what's stopping this from running faster?

537
00:34:16,840 --> 00:34:18,600
 I could make the robot--

538
00:34:18,600 --> 00:34:20,360
 I could make the trajectories faster.

539
00:34:20,360 --> 00:34:23,280
 I chose relatively slow trajectories.

540
00:34:23,280 --> 00:34:27,480
 If I did that, then I think the--

541
00:34:27,480 --> 00:34:28,740
 yes, that's a great question.

542
00:34:28,740 --> 00:34:32,720
 So there will be joint limits on the robot, joint velocity

543
00:34:32,720 --> 00:34:35,500
 limits on the robot that would prevent--

544
00:34:35,500 --> 00:34:37,100
 a lot of times our factory robots--

545
00:34:37,100 --> 00:34:39,000
 this is originally a factory robot--

546
00:34:39,000 --> 00:34:43,400
 are geared to move fairly quickly, but not super fast.

547
00:34:43,400 --> 00:34:45,100
 They're not supposed to be throwing things

548
00:34:45,100 --> 00:34:46,920
 across the room and stuff like that.

549
00:34:46,920 --> 00:34:48,360
 And some robots are.

550
00:34:48,360 --> 00:34:49,980
 So there will be joint velocities

551
00:34:49,980 --> 00:34:51,980
 that will be a constraint at some point.

552
00:34:51,980 --> 00:34:53,900
 On EWA in particular, there's joint--

553
00:34:53,900 --> 00:34:55,780
 you can hit the joint velocity limits.

554
00:34:55,780 --> 00:34:59,160
 If I just used this differential IK controller,

555
00:34:59,160 --> 00:35:01,320
 then I would also worry, as I started getting close

556
00:35:01,320 --> 00:35:04,000
 to those limits, that my tracking error might increase.

557
00:35:04,000 --> 00:35:07,160
 And so my pick success or my running into things

558
00:35:07,160 --> 00:35:07,820
 would increase.

559
00:35:07,820 --> 00:35:09,660
 And a better controller at the lower level

560
00:35:09,660 --> 00:35:13,520
 could-- or tighter gains, if everything's stable,

561
00:35:13,520 --> 00:35:16,000
 could make that run faster.

562
00:35:16,000 --> 00:35:18,640
 I hope to show you some beautiful motions of the EWAs

563
00:35:18,640 --> 00:35:24,840
 in hardware soon, before we get too far in the class.

564
00:35:24,840 --> 00:35:25,340
 Yes?

565
00:35:25,340 --> 00:35:25,840
 [INAUDIBLE]

566
00:35:25,840 --> 00:35:33,400
 You know the algorithm.

567
00:35:33,400 --> 00:35:35,880
 So it looks at the point cloud.

568
00:35:35,880 --> 00:35:37,720
 It doesn't know anything about the objects.

569
00:35:37,720 --> 00:35:38,880
 It looks at the point cloud.

570
00:35:38,880 --> 00:35:40,920
 It finds antipodal grasps.

571
00:35:40,920 --> 00:35:44,200
 It takes my scoring function and takes the best antipodal grasp

572
00:35:44,200 --> 00:35:45,600
 score.

573
00:35:45,600 --> 00:35:50,620
 So it could do anything.

574
00:35:50,620 --> 00:35:52,480
 There's actually a pretty funny failure case.

575
00:35:52,480 --> 00:35:57,760
 If it drops the object immediately down in the bin,

576
00:35:57,760 --> 00:35:59,840
 then it backs off, but not enough.

577
00:35:59,840 --> 00:36:02,240
 I could easily have fixed this, but I just didn't.

578
00:36:02,240 --> 00:36:03,640
 It backs off, but not enough.

579
00:36:03,640 --> 00:36:06,760
 And then the hand is still in the camera.

580
00:36:06,760 --> 00:36:08,840
 And it sees a point cloud and some really appealing

581
00:36:08,840 --> 00:36:10,260
 antipodal grasp.

582
00:36:10,260 --> 00:36:15,000
 So it starts going-- in thin air, trying to pick itself.

583
00:36:15,000 --> 00:36:16,840
 But then after that, it gets out of the way.

584
00:36:16,840 --> 00:36:21,440
 And so it's just a one-time snafu, and I let it go.

585
00:36:21,440 --> 00:36:21,920
 OK.

586
00:36:21,920 --> 00:36:23,880
 So I feel like you know how to do-- oh, sorry.

587
00:36:23,880 --> 00:36:24,380
 Go ahead.

588
00:36:24,380 --> 00:36:24,880
 [INAUDIBLE]

589
00:36:24,880 --> 00:36:31,240
 I cropped.

590
00:36:31,240 --> 00:36:32,960
 So I feel like it's not cheating,

591
00:36:32,960 --> 00:36:35,400
 since I know where the bins are in this application,

592
00:36:35,400 --> 00:36:38,760
 to just crop the point cloud to be in the interior of the bin.

593
00:36:38,760 --> 00:36:41,400
 So it won't find that.

594
00:36:41,400 --> 00:36:44,960
 Although, one strategy for getting that one--

595
00:36:44,960 --> 00:36:46,920
 I guess that one's just going to hit me every single time

596
00:36:46,920 --> 00:36:47,720
 in this run, right?

597
00:36:47,720 --> 00:36:49,840
 Because it's never going to move.

598
00:36:49,840 --> 00:36:52,680
 And every time it's going to be the last one, it tries to pick.

599
00:36:52,680 --> 00:36:54,520
 So every time it's finished with the x bin,

600
00:36:54,520 --> 00:36:58,960
 it's going to try to do this for five or six times.

601
00:36:58,960 --> 00:37:01,360
 On the real robot, we actually-- so we did something

602
00:37:01,360 --> 00:37:03,440
 where we kind of pushed it out of the corner.

603
00:37:03,440 --> 00:37:04,520
 That was a pretty good way.

604
00:37:04,520 --> 00:37:06,720
 But the other thing we did, actually, to your point,

605
00:37:06,720 --> 00:37:10,000
 was it was really good to pick the bin and shake it.

606
00:37:10,000 --> 00:37:12,440
 That was another good way to get things out of the corner.

607
00:37:12,440 --> 00:37:15,480
 But I didn't let it do that.

608
00:37:15,480 --> 00:37:17,560
 So you have the entire toolkit for this,

609
00:37:17,560 --> 00:37:21,300
 except for the high-level recovery-type planning.

610
00:37:21,300 --> 00:37:22,840
 And so I want to talk about that now.

611
00:37:22,840 --> 00:37:39,200
 Lesson learned.

612
00:37:39,200 --> 00:37:43,240
 I won't put an enormous file in the middle of my presentation.

613
00:37:43,240 --> 00:37:51,860
 OK.

614
00:37:51,860 --> 00:37:53,280
 I'm just going to leave it there,

615
00:37:53,280 --> 00:37:54,360
 even though I'm not quite ready for that,

616
00:37:54,360 --> 00:37:56,040
 just so that the browser is responsive.

617
00:37:56,040 --> 00:37:59,280
 OK.

618
00:37:59,280 --> 00:38:03,240
 So the way that I programmed that was with a state machine--

619
00:38:03,240 --> 00:38:07,480
 switch off over here-- which is the simplest

620
00:38:07,480 --> 00:38:11,560
 type of programming at the sort of task level.

621
00:38:11,560 --> 00:38:14,560
 Where did I put the-- oh, here it is.

622
00:38:14,560 --> 00:38:15,560
 It's getting old.

623
00:38:15,560 --> 00:38:20,080
 OK.

624
00:38:20,080 --> 00:38:22,800
 So I want to talk a bit about programming

625
00:38:22,800 --> 00:38:32,080
 sort of at the task level.

626
00:38:32,080 --> 00:38:36,000
 That's what people often call it.

627
00:38:36,000 --> 00:38:37,480
 Not the individual motion.

628
00:38:37,480 --> 00:38:39,680
 This is maybe as opposed to motion planning.

629
00:38:39,680 --> 00:38:41,560
 Task planning is high level.

630
00:38:41,560 --> 00:38:43,460
 What should I do in what order to accomplish

631
00:38:43,460 --> 00:38:45,920
 my long-term goals?

632
00:38:45,920 --> 00:38:49,120
 Should I be picking out of the bin on the x-axis

633
00:38:49,120 --> 00:38:51,120
 or the bin on the y-axis, for instance?

634
00:38:51,120 --> 00:38:52,760
 Should I be-- did I drop something?

635
00:38:52,760 --> 00:38:54,300
 Do I have to stop and take a recovery?

636
00:38:54,300 --> 00:38:55,800
 These are the high-level plans.

637
00:38:55,800 --> 00:38:57,040
 OK.

638
00:38:57,040 --> 00:38:59,040
 And the simplest approach we'll talk about

639
00:38:59,040 --> 00:39:01,160
 would just be writing a finite state machine.

640
00:39:02,080 --> 00:39:08,440
 Which, if you've taken an algorithms class,

641
00:39:08,440 --> 00:39:09,520
 you've seen these.

642
00:39:09,520 --> 00:39:12,560
 It's called an FSMs, for instance.

643
00:39:12,560 --> 00:39:14,400
 It's their theory of computation class.

644
00:39:14,400 --> 00:39:17,200
 It thinks about state machines and what they can describe

645
00:39:17,200 --> 00:39:17,680
 and the like.

646
00:39:17,680 --> 00:39:20,320
 OK.

647
00:39:20,320 --> 00:39:24,280
 So this robot, or this demo, has four states.

648
00:39:24,280 --> 00:39:29,120
 It would be better if it had more, probably.

649
00:39:29,120 --> 00:39:31,880
 But I implemented four and got pretty far with that.

650
00:39:31,880 --> 00:39:38,920
 So the first one is just waiting for objects to settle.

651
00:39:38,920 --> 00:39:47,840
 My warm-up phase.

652
00:39:47,840 --> 00:39:50,560
 Because remember, I initialized the objects in the sky,

653
00:39:50,560 --> 00:39:51,560
 and they fall down.

654
00:39:51,560 --> 00:39:54,940
 And until I put this mode in, it would try to pick--

655
00:39:54,940 --> 00:39:57,240
 it would take the point cloud when the things were still

656
00:39:57,240 --> 00:39:58,320
 falling, and then it would be trying

657
00:39:58,320 --> 00:39:59,440
 to pick objects in the sky.

658
00:39:59,440 --> 00:40:01,760
 But by the time it gets there, they were long gone.

659
00:40:01,760 --> 00:40:02,760
 So that was ridiculous.

660
00:40:02,760 --> 00:40:06,120
 And I decided to add an initial setup phase where it just

661
00:40:06,120 --> 00:40:09,640
 waits for a second or two.

662
00:40:09,640 --> 00:40:14,960
 And then I'm going to be picked from-- I'm in a mode where

663
00:40:14,960 --> 00:40:20,680
 I'm picking from the x bin, which is just

664
00:40:20,680 --> 00:40:23,440
 what I'm calling the bin that's on the positive x-axis,

665
00:40:23,440 --> 00:40:26,800
 because I didn't have a left or right, obviously.

666
00:40:26,800 --> 00:40:31,400
 A different mode for picking from the y bin, which

667
00:40:31,400 --> 00:40:32,800
 is actually on the negative y-axis.

668
00:40:32,800 --> 00:40:40,880
 And then I have this go home mode,

669
00:40:40,880 --> 00:40:50,920
 which is when things get bad, it shakes itself out of problems

670
00:40:50,920 --> 00:40:53,320
 and does the right thing most of the time.

671
00:40:53,320 --> 00:40:53,820
 Cool.

672
00:40:53,820 --> 00:41:03,040
 So I can think about the way that those modes interact

673
00:41:03,040 --> 00:41:05,360
 by drawing a simple state machine diagram.

674
00:41:05,360 --> 00:41:14,200
 I guess there's also technically one more which would be done.

675
00:41:14,200 --> 00:41:16,080
 I didn't call it a state because I just

676
00:41:16,080 --> 00:41:17,280
 used it as a cert statement.

677
00:41:17,280 --> 00:41:20,000
 If it can't find any objects, if it tries like six times

678
00:41:20,000 --> 00:41:22,040
 and there's no place to pick in six times,

679
00:41:22,040 --> 00:41:26,240
 then it's like I'm just going to assert failure.

680
00:41:26,240 --> 00:41:28,640
 But I've got my weight.

681
00:41:28,640 --> 00:41:37,200
 I've got my pick from x, my pick from y, and then my go home.

682
00:41:37,200 --> 00:41:44,760
 And it's useful to think about organizing

683
00:41:44,760 --> 00:41:48,520
 the behaviors of the robot in a graph type structure, where

684
00:41:48,520 --> 00:41:51,680
 I can think about from waiting, after I've

685
00:41:51,680 --> 00:41:55,320
 done waiting for the objects to fall,

686
00:41:55,320 --> 00:41:58,240
 I allow it to transition to either of these two

687
00:41:58,240 --> 00:42:00,080
 possible states.

688
00:42:00,080 --> 00:42:03,480
 It prefers to go to pick x.

689
00:42:03,480 --> 00:42:05,600
 I'll tell you the conditions in a second.

690
00:42:05,600 --> 00:42:07,440
 Certainly, if I'm picking x and I've

691
00:42:07,440 --> 00:42:09,000
 decided there's nothing left to pick,

692
00:42:09,000 --> 00:42:11,600
 then I can transition to picking y.

693
00:42:11,600 --> 00:42:15,160
 If I'm picking from the y bin and I can't find any graphs,

694
00:42:15,160 --> 00:42:17,040
 I'll switch back to picking from the x.

695
00:42:20,920 --> 00:42:24,640
 My logic is basically deciding what

696
00:42:24,640 --> 00:42:26,320
 would I do to continue here and do

697
00:42:26,320 --> 00:42:30,880
 I need to transition to the other mode.

698
00:42:30,880 --> 00:42:33,120
 Similarly, from either of those states,

699
00:42:33,120 --> 00:42:36,200
 if I get myself with large tracking error,

700
00:42:36,200 --> 00:42:38,080
 then I can just give up and go home.

701
00:42:38,080 --> 00:42:39,640
 We didn't see it happen once in that.

702
00:42:39,640 --> 00:42:43,240
 It hopefully doesn't happen too often.

703
00:42:43,240 --> 00:42:46,960
 And I can do that from either of these states.

704
00:42:46,960 --> 00:42:49,680
 And the go home, technically, it almost always

705
00:42:49,680 --> 00:42:52,320
 goes to pick x, but it could actually

706
00:42:52,320 --> 00:42:55,120
 go to pick y if there was nothing in x.

707
00:42:55,120 --> 00:42:57,720
 Maybe I'll even say it really kind of goes to pick x

708
00:42:57,720 --> 00:43:00,440
 and then transitions from there here.

709
00:43:00,440 --> 00:43:01,400
 That's how I coded it.

710
00:43:01,400 --> 00:43:13,920
 So this edge here, if I were to just draw it,

711
00:43:13,920 --> 00:43:16,840
 what are the conditions on this?

712
00:43:16,840 --> 00:43:18,680
 The condition on this is am I done waiting?

713
00:43:18,680 --> 00:43:24,680
 More than one second has elapsed.

714
00:43:24,680 --> 00:43:44,880
 And I found a grasp in the x bin.

715
00:43:44,880 --> 00:43:46,160
 This is simple stuff.

716
00:43:46,160 --> 00:43:51,520
 But that's the logic I encoded on that edge, effectively.

717
00:43:51,520 --> 00:43:54,160
 And similarly, I'll transition from here to here.

718
00:43:54,160 --> 00:43:56,680
 If I can't find any more grasps here,

719
00:43:56,680 --> 00:43:58,520
 and I find a grasp over in y, then I'll

720
00:43:58,520 --> 00:44:00,840
 switch mode picking in y.

721
00:44:00,840 --> 00:44:02,600
 That way, it will repeatedly pick from y

722
00:44:02,600 --> 00:44:04,120
 until it's roughly done.

723
00:44:04,120 --> 00:44:06,880
 So it's staying in this state.

724
00:44:06,880 --> 00:44:08,180
 And then it'll go back.

725
00:44:08,180 --> 00:44:13,800
 If I had no internal mode logic, then it might pick from x.

726
00:44:13,800 --> 00:44:16,000
 And then the next time, it might find x again.

727
00:44:16,000 --> 00:44:16,680
 It'd be kind of annoying.

728
00:44:16,680 --> 00:44:18,600
 It would just move one object back and forth.

729
00:44:18,600 --> 00:44:20,880
 I want some sort of persistence saying

730
00:44:20,880 --> 00:44:22,280
 to pick from x until you're done,

731
00:44:22,280 --> 00:44:23,960
 then pick from y until you're done.

732
00:44:23,960 --> 00:44:27,220
 So I make these edges not transition

733
00:44:27,220 --> 00:44:28,920
 until you've failed to find a grasp.

734
00:44:28,920 --> 00:44:35,120
 No grasp.

735
00:44:41,360 --> 00:44:44,840
 Now, this turns out to be a powerful methodology.

736
00:44:44,840 --> 00:44:50,520
 I can transition to this if I can't find any grasps.

737
00:44:50,520 --> 00:44:57,800
 That's the no grasp cases.

738
00:44:57,800 --> 00:45:07,280
 This is a very simple version of the basic state machinery.

739
00:45:07,280 --> 00:45:10,560
 But you'd be surprised how many robots

740
00:45:10,560 --> 00:45:12,180
 you've seen out there that are probably

741
00:45:12,180 --> 00:45:13,720
 using something very much like this

742
00:45:13,720 --> 00:45:14,840
 to program the task level.

743
00:45:14,840 --> 00:45:20,560
 The reason you have to think about it like this-- so we're

744
00:45:20,560 --> 00:45:23,480
 used to writing procedural code.

745
00:45:23,480 --> 00:45:27,080
 You're used to writing code that says, do this, then do this,

746
00:45:27,080 --> 00:45:30,960
 then do this, for loop, while loop.

747
00:45:30,960 --> 00:45:35,080
 That's the way we're all most used to writing code.

748
00:45:35,080 --> 00:45:39,440
 You don't get to do that if you have to be a robot

749
00:45:39,440 --> 00:45:42,320
 or in a simulation where you have to have an answer,

750
00:45:42,320 --> 00:45:46,120
 you have to have an action, something that you must output

751
00:45:46,120 --> 00:45:47,480
 at every time step.

752
00:45:47,480 --> 00:45:51,580
 I can't be somewhere in the while loop doing my thing.

753
00:45:51,580 --> 00:45:53,920
 You must have an answer at every time.

754
00:45:53,920 --> 00:45:56,000
 And that's what changes the programming paradigm

755
00:45:56,000 --> 00:45:58,520
 from instead of the pure procedural logic

756
00:45:58,520 --> 00:46:01,400
 to something that's organized more like a state machine

757
00:46:01,400 --> 00:46:04,880
 or more like behavior trees or more something like this.

758
00:46:04,880 --> 00:46:06,600
 It's the requirement that you must tell me

759
00:46:06,600 --> 00:46:08,720
 what to do at every time step.

760
00:46:08,720 --> 00:46:11,440
 You're not allowed to go off and think forever.

761
00:46:11,440 --> 00:46:18,960
 All right, so how do you implement that as a system?

762
00:46:18,960 --> 00:46:20,420
 Because we're trying to use this--

763
00:46:20,420 --> 00:46:22,500
 we're going to ultimately write our planner system.

764
00:46:22,500 --> 00:46:32,680
 Well, it's not that hard to do.

765
00:46:32,680 --> 00:46:36,520
 I'm actually very interested-- maybe at the end of the lecture

766
00:46:36,520 --> 00:46:38,320
 I'll ask you again about what you

767
00:46:38,320 --> 00:46:40,280
 think would help you the most in your projects.

768
00:46:40,280 --> 00:46:42,600
 Maybe you can even tell me on your project proposals.

769
00:46:42,600 --> 00:46:46,920
 Because I've always felt like low level control, motion

770
00:46:46,920 --> 00:46:49,600
 planning, even perception, we've given you

771
00:46:49,600 --> 00:46:50,600
 a lot of tools for that.

772
00:46:50,600 --> 00:46:54,520
 But people feel limited in their projects by this level

773
00:46:54,520 --> 00:46:57,520
 because I haven't given you lots of tools for this.

774
00:46:57,520 --> 00:46:59,240
 So you could tell me what is most useful.

775
00:46:59,240 --> 00:47:02,720
 But the simplest version, these kind of state machine diagrams

776
00:47:02,720 --> 00:47:05,560
 are very easy to write in the systems framework.

777
00:47:05,560 --> 00:47:09,040
 All you do is use the simplest version of it.

778
00:47:09,040 --> 00:47:12,760
 There are more advanced versions that actually do event detection

779
00:47:12,760 --> 00:47:15,400
 to decide to transition.

780
00:47:15,400 --> 00:47:16,600
 Let's leave that out for now.

781
00:47:16,600 --> 00:47:21,440
 Let's just say every dt, every time step,

782
00:47:21,440 --> 00:47:23,360
 I'm going to start up, I'm going to wake up,

783
00:47:23,360 --> 00:47:25,080
 I'm in one of these modes.

784
00:47:25,080 --> 00:47:27,000
 And I take whatever action that's inside there

785
00:47:27,000 --> 00:47:28,360
 and I output that to my output port.

786
00:47:28,360 --> 00:47:30,500
 And I'll decide should I transition to the next one

787
00:47:30,500 --> 00:47:31,880
 for the next time step.

788
00:47:31,880 --> 00:47:35,160
 That's a simple discrete time difference equation type

789
00:47:35,160 --> 00:47:35,920
 system.

790
00:47:35,920 --> 00:47:38,400
 It happens to have complicated logic, potentially.

791
00:47:38,400 --> 00:47:40,600
 The conditions about whether you change,

792
00:47:40,600 --> 00:47:42,080
 it's not a linear dynamical system.

793
00:47:42,080 --> 00:47:46,400
 But it's a perfectly reasonable conditional difference

794
00:47:46,400 --> 00:47:48,320
 equation.

795
00:47:48,320 --> 00:47:50,120
 And you can do that by just saying,

796
00:47:50,120 --> 00:47:53,040
 I'm going to go ahead and tell myself to update.

797
00:47:53,040 --> 00:47:55,880
 In that example, I updated every 0.1 seconds.

798
00:47:55,880 --> 00:47:59,640
 The simulator is taking time steps at like a millisecond.

799
00:47:59,640 --> 00:48:02,240
 So the physics is updating very often.

800
00:48:02,240 --> 00:48:05,080
 The planner is only updating 10 times a second

801
00:48:05,080 --> 00:48:07,560
 because you don't need to decide things

802
00:48:07,560 --> 00:48:14,920
 if I drop the thing at 100 or even 1,000 hertz.

803
00:48:14,920 --> 00:48:17,840
 And then, so basically it says, call my update function

804
00:48:17,840 --> 00:48:20,800
 every 0.1 seconds.

805
00:48:20,800 --> 00:48:26,040
 And then I'm going to declare that I have some state.

806
00:48:26,040 --> 00:48:31,400
 I tried to use words and I used a Python enum

807
00:48:31,400 --> 00:48:34,000
 just to make it readable.

808
00:48:34,000 --> 00:48:36,960
 So if I want to use a Python enum as my state,

809
00:48:36,960 --> 00:48:40,040
 we call that an abstract value state.

810
00:48:40,040 --> 00:48:42,200
 I can tell you if you like why it's abstract value.

811
00:48:42,200 --> 00:48:44,000
 Maybe actually, maybe you care.

812
00:48:44,000 --> 00:48:51,040
 It's a programming paradigm called type erasure.

813
00:48:51,040 --> 00:48:53,080
 So basically, I want to be able to pass things

814
00:48:53,080 --> 00:48:56,320
 through the systems framework without understanding the type.

815
00:48:56,320 --> 00:48:59,120
 Think about converting it to like a void pointer, void star

816
00:48:59,120 --> 00:49:00,720
 pointer, or something like that.

817
00:49:00,720 --> 00:49:03,880
 And I could take any-- if I take any kind of type

818
00:49:03,880 --> 00:49:05,460
 and I want to turn it into something

819
00:49:05,460 --> 00:49:07,640
 that I reason about in the systems framework,

820
00:49:07,640 --> 00:49:09,880
 I can make it an abstract value.

821
00:49:09,880 --> 00:49:11,360
 It erases the type.

822
00:49:11,360 --> 00:49:12,280
 It passes it through.

823
00:49:12,280 --> 00:49:15,600
 But the people who read it know how to put the type back on.

824
00:49:15,600 --> 00:49:18,760
 That's what the abstract value make and abstract value get

825
00:49:18,760 --> 00:49:23,520
 does, is it just erases the type and passes it through

826
00:49:23,520 --> 00:49:25,440
 and then adds the type back.

827
00:49:25,440 --> 00:49:27,440
 So if it looks weird in the code,

828
00:49:27,440 --> 00:49:30,400
 it's doing something clever, standard?

829
00:49:30,400 --> 00:49:31,840
 I don't know.

830
00:49:31,840 --> 00:49:33,120
 OK.

831
00:49:33,120 --> 00:49:36,160
 So I just say I've got a state here,

832
00:49:36,160 --> 00:49:38,240
 which is of this planner state type.

833
00:49:38,240 --> 00:49:41,840
 And its initial value is wait for objects to settle.

834
00:49:41,840 --> 00:49:43,080
 Right?

835
00:49:43,080 --> 00:49:44,280
 Simple.

836
00:49:44,280 --> 00:49:47,640
 And then in my update, I can get out of my context.

837
00:49:47,640 --> 00:49:50,360
 So that just declares something that lives in the context, which

838
00:49:50,360 --> 00:49:52,040
 has a erased type.

839
00:49:52,040 --> 00:49:53,520
 I don't even know what it is.

840
00:49:53,520 --> 00:49:57,580
 But the context can reason about it with the type erasure idea.

841
00:49:57,580 --> 00:49:59,740
 And I can get it back at the beginning of my update

842
00:49:59,740 --> 00:50:03,000
 context, and then I can write it to my context

843
00:50:03,000 --> 00:50:05,920
 at the end, whatever my new decision of my new mode was.

844
00:50:05,920 --> 00:50:07,480
 And in the middle, I can do all kinds

845
00:50:07,480 --> 00:50:09,720
 of logic about which state I should go to next,

846
00:50:09,720 --> 00:50:12,280
 what my actions are during that state.

847
00:50:12,280 --> 00:50:15,680
 That's the basic way that you write a difference equation

848
00:50:15,680 --> 00:50:17,320
 that's using some sort of abstract type,

849
00:50:17,320 --> 00:50:18,640
 like a mode that I'm in.

850
00:50:18,640 --> 00:50:23,480
 Do people like when I talk about that?

851
00:50:23,480 --> 00:50:26,360
 Or this isn't real robotics?

852
00:50:26,360 --> 00:50:26,840
 Yeah?

853
00:50:26,840 --> 00:50:29,280
 OK.

854
00:50:29,280 --> 00:50:30,120
 OK, good.

855
00:50:30,120 --> 00:50:35,920
 And then the other piece that's happening here

856
00:50:35,920 --> 00:50:42,160
 to make that work is when I transition from wait

857
00:50:42,160 --> 00:50:45,920
 to pick, for instance, when I transition into either pick

858
00:50:45,920 --> 00:50:48,880
 or pick x, pick y, or even go home,

859
00:50:48,880 --> 00:50:51,120
 I'm actually calling my planner.

860
00:50:51,120 --> 00:50:53,920
 Only on the transition, not when I'm inside it.

861
00:50:53,920 --> 00:50:56,440
 I call my planner saying, when I transition in,

862
00:50:56,440 --> 00:50:58,400
 I'm going to decide from where I am right now,

863
00:50:58,400 --> 00:51:01,560
 how do I go down and pick and place?

864
00:51:01,560 --> 00:51:03,320
 It's using exactly the stuff you've known.

865
00:51:03,320 --> 00:51:05,280
 I pulled it right out of the previous notebook.

866
00:51:05,280 --> 00:51:08,560
 I've used make gripper frames, make gripper pose trajectory,

867
00:51:08,560 --> 00:51:10,840
 make gripper commanded trajectory, right out

868
00:51:10,840 --> 00:51:11,880
 of the existing examples.

869
00:51:11,880 --> 00:51:18,600
 But I want to save that plan so I don't have to recompute it,

870
00:51:18,600 --> 00:51:20,640
 so I add that to my context.

871
00:51:20,640 --> 00:51:23,220
 I just say I'm going to take the whole plan, which

872
00:51:23,220 --> 00:51:26,600
 is a piecewise pose or piecewise polynomial,

873
00:51:26,600 --> 00:51:29,200
 and I'll register that with the context also.

874
00:51:29,200 --> 00:51:31,480
 That way it's available when I'm inside here.

875
00:51:31,480 --> 00:51:33,360
 I can pull up what's my plan, and I can just

876
00:51:33,360 --> 00:51:36,560
 evaluate the trajectory at the current time.

877
00:51:36,560 --> 00:51:38,960
 That's the architecture.

878
00:51:38,960 --> 00:51:41,360
 So you can imagine assembling pretty--

879
00:51:41,360 --> 00:51:44,320
 I just write if statements in order

880
00:51:44,320 --> 00:51:47,280
 to make this state machine logic.

881
00:51:47,280 --> 00:51:50,180
 And I can make my plans and declare any internal state

882
00:51:50,180 --> 00:51:54,320
 that these things need with the systems framework.

883
00:51:54,320 --> 00:51:55,840
 And it can do all these things.

884
00:51:55,840 --> 00:52:05,160
 So the architecture then is I actually pulled out--

885
00:52:05,160 --> 00:52:07,240
 whenever you can be more modular in the code,

886
00:52:07,240 --> 00:52:10,360
 that way I can reuse this in the next example or whatever.

887
00:52:10,360 --> 00:52:11,440
 I try to pull things out.

888
00:52:11,440 --> 00:52:13,880
 So I have the grasp selection algorithm

889
00:52:13,880 --> 00:52:16,480
 is put out into one system.

890
00:52:16,480 --> 00:52:20,040
 It expects three cameras to tell me what the point cloud are.

891
00:52:20,040 --> 00:52:21,720
 But I use two copies of this.

892
00:52:21,720 --> 00:52:25,280
 I use one for the y bin and one for the x bin.

893
00:52:25,280 --> 00:52:28,200
 I just tell them for the one bin,

894
00:52:28,200 --> 00:52:30,360
 you're going to use camera 0, 1, 2.

895
00:52:30,360 --> 00:52:34,920
 The other one, you're going to use cameras 3, 4, 5.

896
00:52:34,920 --> 00:52:40,280
 Body poses is one of the output of this manipulation station,

897
00:52:40,280 --> 00:52:41,960
 which just tells me where my gripper is.

898
00:52:41,960 --> 00:52:45,040
 That's what roughly it's the internal state

899
00:52:45,040 --> 00:52:48,520
 estimate of the manipulation station.

900
00:52:48,520 --> 00:52:52,040
 And it does the sampling algorithm.

901
00:52:52,040 --> 00:52:56,760
 And it tells me what the cost was and the best pose,

902
00:52:56,760 --> 00:52:58,120
 the best cost and the best pose.

903
00:52:58,120 --> 00:53:00,440
 If that cost is infinite, then I've

904
00:53:00,440 --> 00:53:02,240
 considered myself to have failed the plan.

905
00:53:02,240 --> 00:53:08,640
 Now the cool thing is the systems framework

906
00:53:08,640 --> 00:53:11,360
 tries to optimize some of these operations for you.

907
00:53:11,360 --> 00:53:14,960
 So if nobody asks for the output of the grasp selector,

908
00:53:14,960 --> 00:53:16,400
 then it doesn't do any computation.

909
00:53:16,400 --> 00:53:18,720
 It only does that computation on when you say,

910
00:53:18,720 --> 00:53:19,960
 give me your output.

911
00:53:19,960 --> 00:53:23,860
 So the algorithm here just says, sample 100 points, whatever.

912
00:53:23,860 --> 00:53:25,440
 But it's not running most of the time.

913
00:53:25,440 --> 00:53:28,960
 It's only running when I transition in the planner

914
00:53:28,960 --> 00:53:31,920
 on this, or I decide to transition,

915
00:53:31,920 --> 00:53:34,480
 and I ask, what's your grasp?

916
00:53:34,480 --> 00:53:39,920
 So there's just a mental switch of saying,

917
00:53:39,920 --> 00:53:44,440
 how do you write code that gives an answer every time?

918
00:53:44,440 --> 00:53:46,360
 And state machines are a way to think about that.

919
00:53:46,360 --> 00:53:49,920
 But otherwise, it's pretty standard stuff.

920
00:53:49,920 --> 00:53:55,000
 The planner, it has a bigger job,

921
00:53:55,000 --> 00:53:58,640
 just because this x-bin grasp and y-bin grasp

922
00:53:58,640 --> 00:54:01,320
 are coming from the two grasp selectors.

923
00:54:01,320 --> 00:54:04,520
 But it has to know where the arm is

924
00:54:04,520 --> 00:54:09,440
 and what's the current gripper open and closed.

925
00:54:09,440 --> 00:54:11,120
 Basically, this is the gripper pose,

926
00:54:11,120 --> 00:54:13,480
 and this is the gripper open close.

927
00:54:13,480 --> 00:54:17,440
 And then it outputs-- it makes its plan.

928
00:54:17,440 --> 00:54:19,560
 It looks at what time it is.

929
00:54:19,560 --> 00:54:21,480
 It looks at the plan that it's already saved,

930
00:54:21,480 --> 00:54:25,560
 and it just pulls out xwg, the gripper commanded pose,

931
00:54:25,560 --> 00:54:27,040
 hands that down to differential IK.

932
00:54:27,040 --> 00:54:32,060
 All the other three are just to make it

933
00:54:32,060 --> 00:54:37,160
 so you can stop using diff IK and go home if you need to.

934
00:54:37,160 --> 00:54:39,800
 I have to be able to switch between using diff IK

935
00:54:39,800 --> 00:54:41,280
 or not using diff IK downstream.

936
00:54:41,280 --> 00:54:43,320
 That's what my control mode is.

937
00:54:43,320 --> 00:54:48,200
 I have to send the EWA position trajectory when I'm doing that.

938
00:54:48,200 --> 00:54:52,520
 And I also have to tell diff IK to stop trying to integrate

939
00:54:52,520 --> 00:54:55,880
 and just look at the current state of the robot.

940
00:54:55,880 --> 00:54:59,160
 Otherwise, if you turned off diff IK for a while

941
00:54:59,160 --> 00:55:02,120
 and then turned it back on, it would have no idea where you are

942
00:55:02,120 --> 00:55:04,000
 and would command something completely wrong.

943
00:55:04,000 --> 00:55:05,840
 So you just have to be able to say, hey, diff IK,

944
00:55:05,840 --> 00:55:06,960
 look at your current state.

945
00:55:06,960 --> 00:55:09,080
 Don't try to integrate forward.

946
00:55:09,080 --> 00:55:11,420
 So I would say those are just details.

947
00:55:11,420 --> 00:55:13,800
 I was borderline about whether I should even put them in,

948
00:55:13,800 --> 00:55:15,800
 but I think it just adds so much more robustness

949
00:55:15,800 --> 00:55:17,680
 and it exercises the ideas a little bit more.

950
00:55:17,680 --> 00:55:20,360
 So as an example, I thought that was useful to have.

951
00:55:20,360 --> 00:55:20,860
 Yes?

952
00:55:20,860 --> 00:55:21,360
 [INAUDIBLE]

953
00:55:21,360 --> 00:55:24,700
 Yeah.

954
00:55:24,700 --> 00:55:25,200
 [INAUDIBLE]

955
00:55:25,200 --> 00:55:32,000
 Yes.

956
00:55:32,000 --> 00:55:32,640
 Yes.

957
00:55:32,640 --> 00:55:35,560
 So as you were asking your question,

958
00:55:35,560 --> 00:55:36,940
 I was anticipating your question.

959
00:55:36,940 --> 00:55:38,760
 I realized I forgot the self transitions.

960
00:55:38,760 --> 00:55:40,640
 But you asked something different.

961
00:55:40,640 --> 00:55:43,920
 So I will ignore that error.

962
00:55:43,920 --> 00:55:47,920
 That is completely hard coded.

963
00:55:47,920 --> 00:55:50,680
 Just to make the demo interesting,

964
00:55:50,680 --> 00:55:54,160
 I basically pick a random point in the bin to put it down.

965
00:55:54,160 --> 00:55:55,520
 It goes to a stereotype gripper.

966
00:55:55,520 --> 00:55:58,040
 This is the make gripper trajectory.

967
00:55:58,040 --> 00:55:59,120
 I just have key frames.

968
00:55:59,120 --> 00:56:01,080
 And every time I'm going to put something down,

969
00:56:01,080 --> 00:56:03,200
 I pick a random place somewhere in the box.

970
00:56:03,200 --> 00:56:04,240
 And I pick that.

971
00:56:04,240 --> 00:56:08,060
 And then I do the pre-pick, post-pick stuff to set it down.

972
00:56:08,060 --> 00:56:09,480
 And every once in a while, you'll

973
00:56:09,480 --> 00:56:12,420
 see something ridiculous, like it'll stack mustard bottles.

974
00:56:12,420 --> 00:56:14,340
 Because it just randomly picked the same place

975
00:56:14,340 --> 00:56:15,640
 a couple times in a row.

976
00:56:15,640 --> 00:56:17,720
 And that wasn't a good idea.

977
00:56:17,720 --> 00:56:21,760
 But next time, probably if that's a tall mustard bottle

978
00:56:21,760 --> 00:56:23,640
 tower, it'll tend to knock it over next time.

979
00:56:23,640 --> 00:56:27,120
 And randomness has been restored.

980
00:56:27,120 --> 00:56:28,040
 Entropy is restored.

981
00:56:28,040 --> 00:56:33,160
 Good.

982
00:56:33,160 --> 00:56:37,440
 So I just want you to feel like you can do that.

983
00:56:37,440 --> 00:56:39,280
 And you have to look at the example,

984
00:56:39,280 --> 00:56:41,980
 or you can just pull this example up and adapt it.

985
00:56:41,980 --> 00:56:43,480
 I want that to be available for you.

986
00:56:43,480 --> 00:56:46,960
 But it's really-- you can author pretty complicated things

987
00:56:46,960 --> 00:56:47,560
 pretty quickly.

988
00:56:47,560 --> 00:56:51,440
 And people do.

989
00:56:51,440 --> 00:56:54,480
 So well, let me just-- I guess I'll say my failure modes first

990
00:56:54,480 --> 00:56:55,280
 here.

991
00:56:55,280 --> 00:56:57,400
 I kind of made a list as I was watching it,

992
00:56:57,400 --> 00:56:58,960
 like what actually makes it fail.

993
00:56:58,960 --> 00:57:01,040
 And I could burn down any one of these

994
00:57:01,040 --> 00:57:02,080
 and make it never happen.

995
00:57:02,080 --> 00:57:04,540
 But I thought it's interesting at this stage of the class

996
00:57:04,540 --> 00:57:08,420
 and say what's actually failing.

997
00:57:08,420 --> 00:57:11,800
 The first one is my initial conditions, like I said,

998
00:57:11,800 --> 00:57:13,160
 is kind of silly.

999
00:57:13,160 --> 00:57:15,160
 And with some probability, like the mustard bottle

1000
00:57:15,160 --> 00:57:17,400
 could be inside the soup can.

1001
00:57:17,400 --> 00:57:18,840
 And multi-body plant says I can't

1002
00:57:18,840 --> 00:57:21,440
 find forces that will get me out of collision in one step.

1003
00:57:21,440 --> 00:57:23,960
 And it fails on time zero, basically.

1004
00:57:23,960 --> 00:57:25,600
 So if it does that, forgive me.

1005
00:57:25,600 --> 00:57:26,640
 Just start it again.

1006
00:57:26,640 --> 00:57:28,240
 It's all good.

1007
00:57:28,240 --> 00:57:33,160
 Again, I could make a better initial guess sequence

1008
00:57:33,160 --> 00:57:35,880
 to resolve that.

1009
00:57:35,880 --> 00:57:38,420
 Motion planning becomes a real bottleneck.

1010
00:57:38,420 --> 00:57:42,500
 This simple heuristic of grasps is too simple.

1011
00:57:42,500 --> 00:57:45,180
 And it will occasionally bump into things.

1012
00:57:45,180 --> 00:57:46,980
 It will occasionally collide the object

1013
00:57:46,980 --> 00:57:49,460
 it's picked up with the bins.

1014
00:57:49,460 --> 00:57:52,660
 It'll occasionally go too close to its own base.

1015
00:57:52,660 --> 00:57:54,900
 So if it chose to go from that corner to that corner,

1016
00:57:54,900 --> 00:57:56,780
 and I just made a straight line interpolation,

1017
00:57:56,780 --> 00:57:58,240
 it'll go way close to its own base.

1018
00:57:58,240 --> 00:58:01,460
 And the arm starts like, I don't know what to do about that.

1019
00:58:01,460 --> 00:58:04,180
 We haven't respected the joint limits of the robot.

1020
00:58:04,180 --> 00:58:08,300
 And so differential IK becomes problematic

1021
00:58:08,300 --> 00:58:11,500
 for those kind of reasons.

1022
00:58:11,500 --> 00:58:15,100
 Ergo, we will spend a week on motion planning in a few weeks.

1023
00:58:15,100 --> 00:58:18,900
 And we'll make that way better.

1024
00:58:18,900 --> 00:58:21,280
 Perception we talked about before, even at the antipodal.

1025
00:58:21,280 --> 00:58:23,900
 You see it in this demo regularly.

1026
00:58:23,900 --> 00:58:26,020
 It'll pick at the corner of an object.

1027
00:58:26,020 --> 00:58:28,740
 And then the object will be swinging around.

1028
00:58:28,740 --> 00:58:30,100
 Because why?

1029
00:58:30,100 --> 00:58:36,940
 Because the wrench generated by the gravitational force

1030
00:58:36,940 --> 00:58:41,620
 is outside the current grasp's friction cone.

1031
00:58:41,620 --> 00:58:44,340
 And so it'll swing.

1032
00:58:44,340 --> 00:58:46,260
 It does do double picks, like we talked about,

1033
00:58:46,260 --> 00:58:49,300
 because it doesn't know what an object is.

1034
00:58:49,300 --> 00:58:51,460
 The phantoms, like I said, it tries to pick itself.

1035
00:58:51,460 --> 00:58:54,300
 If the hand was in the point cloud,

1036
00:58:54,300 --> 00:58:56,260
 it'll be like, oh, that's a good place to pick.

1037
00:58:56,260 --> 00:58:59,900
 It goes up and just picks the phantom hand.

1038
00:58:59,900 --> 00:59:01,480
 That one would be really easy to fix.

1039
00:59:01,480 --> 00:59:04,940
 But I just thought it was hilarious, so I left it.

1040
00:59:04,940 --> 00:59:07,240
 And then the other ones are actually super interesting,

1041
00:59:07,240 --> 00:59:08,940
 I would say.

1042
00:59:08,940 --> 00:59:12,300
 Like, it's actually very hard to do much better in this case.

1043
00:59:12,300 --> 00:59:12,940
 We will do it.

1044
00:59:12,940 --> 00:59:13,820
 We'll try to do it.

1045
00:59:13,820 --> 00:59:17,900
 But we'll use force control and nonprehensile manipulation,

1046
00:59:17,900 --> 00:59:21,100
 is what it's called, to do things that it's not just

1047
00:59:21,100 --> 00:59:22,100
 picking in place.

1048
00:59:22,100 --> 00:59:24,180
 We'll have to use the side of our hand

1049
00:59:24,180 --> 00:59:26,100
 to push objects into the corner, apply

1050
00:59:26,100 --> 00:59:29,320
 forces to get it to lift up so we can get our hand under it.

1051
00:59:29,320 --> 00:59:31,980
 It's not just about getting your hand around it and squeezing.

1052
00:59:31,980 --> 00:59:33,940
 It's going to be much more than that.

1053
00:59:33,940 --> 00:59:35,660
 And when objects get stuck in the corner--

1054
00:59:35,660 --> 00:59:38,260
 I actually had to remove the Cheez-It box from my list.

1055
00:59:38,260 --> 00:59:40,380
 Cheez-It boxes are not allowed in this demo,

1056
00:59:40,380 --> 00:59:43,100
 because they constantly would block all the other objects

1057
00:59:43,100 --> 00:59:44,420
 with something that was too big for the gripper

1058
00:59:44,420 --> 00:59:45,660
 to pick up from the top.

1059
00:59:45,660 --> 00:59:47,660
 And I was just like, no Cheez-It boxes.

1060
00:59:47,660 --> 00:59:48,780
 That's it.

1061
00:59:48,780 --> 00:59:49,660
 That's for next week.

1062
00:59:49,660 --> 00:59:53,760
 OK.

1063
00:59:53,760 --> 00:59:56,980
 So if I were to just-- I wanted to even-- because we

1064
00:59:56,980 --> 00:59:59,020
 got to a certain level of robustness-- this

1065
00:59:59,020 --> 01:00:00,780
 is like the weakest robustness I would ever

1066
01:00:00,780 --> 01:00:02,180
 talk about being robust.

1067
01:00:02,180 --> 01:00:04,420
 But it's actually interesting to think about,

1068
01:00:04,420 --> 01:00:06,220
 like, what would I do if I were to start now

1069
01:00:06,220 --> 01:00:09,740
 applying our stronger tools to make that more robust?

1070
01:00:09,740 --> 01:00:11,900
 There's actually very strong tools you could apply.

1071
01:00:11,900 --> 01:00:15,140
 And if you've had an internship at an autonomous driving

1072
01:00:15,140 --> 01:00:17,380
 startup or something like this, you might have used some

1073
01:00:17,380 --> 01:00:19,420
 of these tools.

1074
01:00:19,420 --> 01:00:22,060
 The difference of going from a little toy project

1075
01:00:22,060 --> 01:00:24,300
 to something that has to work every time, which

1076
01:00:24,300 --> 01:00:25,740
 is far from right now.

1077
01:00:25,740 --> 01:00:27,540
 But there's great tools that we could use.

1078
01:00:27,540 --> 01:00:29,220
 And they're all available if you choose

1079
01:00:29,220 --> 01:00:30,960
 to use them for your projects or whatever.

1080
01:00:30,960 --> 01:00:34,260
 But for instance, when we were working on this,

1081
01:00:34,260 --> 01:00:39,100
 this was also very complicated at the task level.

1082
01:00:39,100 --> 01:00:40,460
 And one of the things that happens

1083
01:00:40,460 --> 01:00:42,340
 is when you're doing so many different things

1084
01:00:42,340 --> 01:00:43,800
 and you have task level interacting

1085
01:00:43,800 --> 01:00:46,500
 with low-level controllers and all these things,

1086
01:00:46,500 --> 01:00:49,780
 really bizarre things can go wrong.

1087
01:00:49,780 --> 01:00:51,260
 When you're writing code, you should

1088
01:00:51,260 --> 01:00:52,900
 try to write-- almost always, you

1089
01:00:52,900 --> 01:00:56,100
 should try to write unit tests or component-level tests.

1090
01:00:56,100 --> 01:00:58,060
 That's the only real way to write code,

1091
01:00:58,060 --> 01:00:59,900
 is to, every time you write a small function,

1092
01:00:59,900 --> 01:01:02,620
 make sure that function does what you want.

1093
01:01:02,620 --> 01:01:06,060
 But for weird interactions between the components

1094
01:01:06,060 --> 01:01:10,060
 that happen when you start taking all this complexity in,

1095
01:01:10,060 --> 01:01:11,140
 you have to do more.

1096
01:01:11,140 --> 01:01:15,140
 You have to do some level of system integration testing.

1097
01:01:15,140 --> 01:01:17,060
 And we're already getting to this point

1098
01:01:17,060 --> 01:01:20,660
 with a simple clutter clearing demo.

1099
01:01:20,660 --> 01:01:23,020
 So the way that we do this-- and again,

1100
01:01:23,020 --> 01:01:25,940
 this is part of the motivation behind the systems framework,

1101
01:01:25,940 --> 01:01:29,380
 declare your state, declare your randomness--

1102
01:01:29,380 --> 01:01:33,020
 is we have a Monte Carlo test suite.

1103
01:01:33,020 --> 01:01:35,940
 You can run off in the cloud lots of clutter clearing

1104
01:01:35,940 --> 01:01:37,780
 simulations.

1105
01:01:37,780 --> 01:01:41,300
 They're all deterministic, given the initial conditions

1106
01:01:41,300 --> 01:01:45,980
 of the initial context, which includes the random seed that

1107
01:01:45,980 --> 01:01:49,060
 governs everything afterwards.

1108
01:01:49,060 --> 01:01:50,940
 And you just let it go off into the cloud,

1109
01:01:50,940 --> 01:01:52,460
 and you write a little thing that

1110
01:01:52,460 --> 01:01:55,700
 detects whether it's a good success or a failure.

1111
01:01:55,700 --> 01:01:58,820
 And it tells you in the next morning how often you've failed.

1112
01:01:58,820 --> 01:02:00,620
 It'll even make a little movie and put it in your inbox

1113
01:02:00,620 --> 01:02:01,340
 if you want.

1114
01:02:01,340 --> 01:02:04,140
 And say, it'll record the last few seconds

1115
01:02:04,140 --> 01:02:07,740
 and tell you these are the statistics of failure,

1116
01:02:07,740 --> 01:02:10,700
 and these are the specific failure cases.

1117
01:02:10,700 --> 01:02:12,340
 And you just hammer on that.

1118
01:02:12,340 --> 01:02:14,060
 You hammer on that, and you actually

1119
01:02:14,060 --> 01:02:16,820
 make your Monte Carlo tests harder

1120
01:02:16,820 --> 01:02:19,000
 if I make the initial conditions more diverse

1121
01:02:19,000 --> 01:02:22,580
 or if I add more sensor noise.

1122
01:02:22,580 --> 01:02:24,700
 On that project, it was actually very interesting,

1123
01:02:24,700 --> 01:02:27,140
 because we had the red team that was

1124
01:02:27,140 --> 01:02:29,940
 trying to make the noise models more aggressive

1125
01:02:29,940 --> 01:02:31,140
 and other things like this.

1126
01:02:31,140 --> 01:02:33,380
 They were trying to make the simulation harder to pass.

1127
01:02:33,380 --> 01:02:34,260
 And then we had the people that were

1128
01:02:34,260 --> 01:02:36,020
 trying to make the robot better.

1129
01:02:36,020 --> 01:02:39,260
 And so there'd be a night where someone would see,

1130
01:02:39,260 --> 01:02:43,060
 like, git commit 1492 or something like this.

1131
01:02:43,060 --> 01:02:45,660
 And then suddenly the score would go way down,

1132
01:02:45,660 --> 01:02:47,160
 because it would start failing more.

1133
01:02:47,160 --> 01:02:49,820
 And you realize, oh, they added new noise models

1134
01:02:49,820 --> 01:02:52,460
 to the dish rack detector.

1135
01:02:52,460 --> 01:02:55,220
 And then you see, like, three commits later, someone fixed it

1136
01:02:55,220 --> 01:02:56,500
 and then it goes back up.

1137
01:02:56,500 --> 01:03:02,220
 And my dream was that we would go up and hit 99.999%.

1138
01:03:02,220 --> 01:03:03,900
 That's not what happened.

1139
01:03:03,900 --> 01:03:07,920
 We stayed basically flat, because the red team was just

1140
01:03:07,920 --> 01:03:12,340
 as fast as the good guys.

1141
01:03:12,340 --> 01:03:14,300
 But that was good, because on the real robot,

1142
01:03:14,300 --> 01:03:16,940
 on the real hardware, we got to 99.9%.

1143
01:03:16,940 --> 01:03:21,660
 But we made the simulation so aggressively bad,

1144
01:03:21,660 --> 01:03:24,000
 it'd be like an autonomous driving always trying to drive

1145
01:03:24,000 --> 01:03:25,440
 down through, I don't know, downtown New Delhi

1146
01:03:25,440 --> 01:03:26,440
 or something like that.

1147
01:03:26,440 --> 01:03:28,760
 Or like a bumper cars or something like that.

1148
01:03:28,760 --> 01:03:30,840
 It was the simulation was throwing everything at you

1149
01:03:30,840 --> 01:03:32,040
 all the time.

1150
01:03:32,040 --> 01:03:36,600
 And the real robot was way easier by the end.

1151
01:03:36,600 --> 01:03:41,640
 And you can use the Monte Carlo simulation suite if you like.

1152
01:03:41,640 --> 01:03:44,880
 We don't have the cloud version of it in the public drake,

1153
01:03:44,880 --> 01:03:47,880
 but we're thinking about putting it over.

1154
01:03:47,880 --> 01:03:49,500
 And there were some really subtle bugs

1155
01:03:49,500 --> 01:03:53,140
 that it would find that we actually found in simulation.

1156
01:03:53,140 --> 01:03:56,300
 And then we're like, no way that could happen on hardware.

1157
01:03:56,300 --> 01:03:58,540
 And then sure enough, we saw it happen on hardware.

1158
01:03:58,540 --> 01:04:00,740
 It was really fun to like-- because actually,

1159
01:04:00,740 --> 01:04:03,300
 when we started turning on all this, the first thing we did

1160
01:04:03,300 --> 01:04:05,460
 is we found all kinds of bugs in our physics engine.

1161
01:04:05,460 --> 01:04:08,540
 Not like easy bugs, we got f equals ma wrong,

1162
01:04:08,540 --> 01:04:11,780
 but like numerical issues when things fall to infinity

1163
01:04:11,780 --> 01:04:14,020
 and stuff like that.

1164
01:04:14,020 --> 01:04:15,320
 Really subtle things.

1165
01:04:15,320 --> 01:04:17,680
 But then when-- or sorry, really like annoying things

1166
01:04:17,680 --> 01:04:19,520
 that were bad failures, I would say.

1167
01:04:19,520 --> 01:04:20,920
 But then as we kept running it, we

1168
01:04:20,920 --> 01:04:22,220
 got to the really good failure.

1169
01:04:22,220 --> 01:04:25,560
 We burned out all the sim to real kind of stuff.

1170
01:04:25,560 --> 01:04:26,800
 And we found very subtle bugs.

1171
01:04:26,800 --> 01:04:28,480
 And this is my favorite little example.

1172
01:04:28,480 --> 01:04:32,160
 OK, so let me see if I can--

1173
01:04:32,160 --> 01:04:33,160
 yeah.

1174
01:04:33,160 --> 01:04:36,600
 So there was this case where the robot would pick up a mug.

1175
01:04:36,600 --> 01:04:37,760
 And we saw this in reality.

1176
01:04:37,760 --> 01:04:41,960
 Pick up a mug, go to set it down, and be like, hmm.

1177
01:04:41,960 --> 01:04:43,520
 And then we would set the mug down,

1178
01:04:43,520 --> 01:04:45,680
 and try to pull the rack out, and pick up the mug.

1179
01:04:45,680 --> 01:04:47,680
 Actually, no, it didn't even pull the rack out.

1180
01:04:47,680 --> 01:04:48,800
 It would just go like this.

1181
01:04:48,800 --> 01:04:51,120
 And it would set it back down, and then pick the mug up.

1182
01:04:51,120 --> 01:04:52,080
 Set it back down.

1183
01:04:52,080 --> 01:04:54,280
 And it just would get in this infinite loop.

1184
01:04:54,280 --> 01:04:56,840
 We're like, OK, that's a super low probability event, right?

1185
01:04:56,840 --> 01:04:58,160
 That was never going to happen.

1186
01:04:58,160 --> 01:04:59,600
 It happened in the real robot.

1187
01:04:59,600 --> 01:05:01,680
 And it was actually an infinite loop, effectively

1188
01:05:01,680 --> 01:05:02,760
 an infinite loop.

1189
01:05:02,760 --> 01:05:03,520
 And this is why.

1190
01:05:03,520 --> 01:05:06,000
 OK, it was the night that the guys added the sensor

1191
01:05:06,000 --> 01:05:08,720
 noise to the dish rack locator.

1192
01:05:08,720 --> 01:05:11,120
 OK, so what they did is it was a very simple noise model.

1193
01:05:11,120 --> 01:05:14,560
 It just said the perception system for the dish rack

1194
01:05:14,560 --> 01:05:16,840
 would just, on every step, pick a random number.

1195
01:05:16,840 --> 01:05:20,440
 It would adjust the true dish rack location by some Gaussian.

1196
01:05:20,440 --> 01:05:21,800
 OK?

1197
01:05:21,800 --> 01:05:24,000
 And there was a particular location

1198
01:05:24,000 --> 01:05:27,720
 of the dish rack that found this weak threshold that somebody

1199
01:05:27,720 --> 01:05:30,160
 had put in their code, where basically,

1200
01:05:30,160 --> 01:05:33,240
 with very high probability, when it started making the motion,

1201
01:05:33,240 --> 01:05:35,680
 with very high probability, it would

1202
01:05:35,680 --> 01:05:38,640
 think the dish rack was out enough to put a mug down.

1203
01:05:38,640 --> 01:05:42,320
 But over the time it took to actually put the mug down,

1204
01:05:42,320 --> 01:05:44,200
 with very high probability, it would

1205
01:05:44,200 --> 01:05:47,320
 find at least one sample that said the dish rack was too far

1206
01:05:47,320 --> 01:05:47,960
 in.

1207
01:05:47,960 --> 01:05:49,480
 And I had to go back and set it down.

1208
01:05:49,480 --> 01:05:51,680
 So the whole planner would go, OK, fine, put it down.

1209
01:05:51,680 --> 01:05:53,080
 But then by the time it went again,

1210
01:05:53,080 --> 01:05:55,720
 with very high probability, it was out enough.

1211
01:05:55,720 --> 01:05:57,360
 And this thing would just go like this.

1212
01:05:57,360 --> 01:05:58,960
 The day we saw that in the real robot,

1213
01:05:58,960 --> 01:06:00,520
 we were like, a simulation is great.

1214
01:06:00,520 --> 01:06:06,040
 And it was like this.

1215
01:06:06,040 --> 01:06:09,200
 This is what I mean about the crazy, hard simulation.

1216
01:06:09,200 --> 01:06:12,200
 The robot was trying to do, in simulation,

1217
01:06:12,200 --> 01:06:14,780
 it was trying to put dishes away while the dish rack was going

1218
01:06:14,780 --> 01:06:17,840
 like this, which is nuts.

1219
01:06:17,840 --> 01:06:20,640
 But being robust to this inferred robustness

1220
01:06:20,640 --> 01:06:21,400
 in the real world.

1221
01:06:21,400 --> 01:06:25,440
 OK.

1222
01:06:25,440 --> 01:06:32,400
 So this type of programming paradigm is very simple.

1223
01:06:32,400 --> 01:06:33,920
 But it's actually used all the time.

1224
01:06:33,920 --> 01:06:35,840
 My favorite example, actually, I used it

1225
01:06:35,840 --> 01:06:37,560
 and under-actuated it, too.

1226
01:06:37,560 --> 01:06:41,320
 Mark Raybert used to talk about his simple controller

1227
01:06:41,320 --> 01:06:43,680
 for a hopping robot.

1228
01:06:43,680 --> 01:06:47,240
 And the best thing about it is it fits completely on one page.

1229
01:06:47,240 --> 01:06:48,960
 And it looks like this.

1230
01:06:48,960 --> 01:06:51,640
 He's got a flight phase, then a landing phase,

1231
01:06:51,640 --> 01:06:53,960
 then a compression of the spring phase.

1232
01:06:53,960 --> 01:06:55,880
 And then it pushes off with the leg.

1233
01:06:55,880 --> 01:06:56,600
 And it unloads.

1234
01:06:56,600 --> 01:06:58,480
 And it's back in the flight phase.

1235
01:06:58,480 --> 01:07:00,040
 He used the language of state machines

1236
01:07:00,040 --> 01:07:03,400
 to talk about his controller and used that language

1237
01:07:03,400 --> 01:07:06,960
 to describe a fairly complicated controller on a page

1238
01:07:06,960 --> 01:07:08,400
 in his book.

1239
01:07:08,400 --> 01:07:11,320
 It's one of my favorite examples of rich behavior coming out

1240
01:07:11,320 --> 01:07:13,200
 of a simple state machine.

1241
01:07:13,200 --> 01:07:17,720
 And for me, it's a goal that we should aspire to

1242
01:07:17,720 --> 01:07:19,040
 with our best control designs.

1243
01:07:19,040 --> 01:07:23,120
 Something so simple could achieve something so complex.

1244
01:07:23,120 --> 01:07:26,160
 But normally, when we do optimization-based control,

1245
01:07:26,160 --> 01:07:29,500
 we don't get that simple stuff out.

1246
01:07:29,500 --> 01:07:31,160
 I don't know if you've seen this version.

1247
01:07:31,160 --> 01:07:33,680
 I know Boston Dynamics puts out awesome videos all the time.

1248
01:07:33,680 --> 01:07:35,600
 This was one from a few years ago.

1249
01:07:35,600 --> 01:07:37,760
 This was Spot opening doors.

1250
01:07:37,760 --> 01:07:39,840
 Andy was a student here.

1251
01:07:39,840 --> 01:07:41,320
 Maybe that's why I like it so much.

1252
01:07:41,320 --> 01:07:45,400
 But Spot is really good at opening doors.

1253
01:07:45,400 --> 01:07:47,120
 I've never seen the code.

1254
01:07:47,120 --> 01:07:49,080
 I know a lot of people that work there

1255
01:07:49,080 --> 01:07:52,960
 but have conversations informally.

1256
01:07:52,960 --> 01:07:54,720
 But I don't know anything for real.

1257
01:07:54,720 --> 01:07:57,480
 But I'm pretty sure that's a state machine that's

1258
01:07:57,480 --> 01:07:59,560
 doing all the same kind of logic we're doing here,

1259
01:07:59,560 --> 01:08:05,720
 where if someone pulls my butt, then probably that case

1260
01:08:05,720 --> 01:08:07,200
 wasn't specifically hand-coded.

1261
01:08:07,200 --> 01:08:10,000
 But it's surprisingly robust behavior

1262
01:08:10,000 --> 01:08:13,000
 in the real world on a real robot.

1263
01:08:13,000 --> 01:08:15,400
 I like to call them robot whisperers, people

1264
01:08:15,400 --> 01:08:18,120
 who know how to write these state machines really well

1265
01:08:18,120 --> 01:08:20,640
 and can make really robust behaviors out.

1266
01:08:20,640 --> 01:08:23,360
 Now, our goals as researchers are probably

1267
01:08:23,360 --> 01:08:28,240
 to do less hand-designed state machines, type controllers

1268
01:08:28,240 --> 01:08:28,960
 like that.

1269
01:08:28,960 --> 01:08:31,000
 But they're getting it done in industry today.

1270
01:08:31,000 --> 01:08:39,960
 And if you look in the robotics open source toolbox,

1271
01:08:39,960 --> 01:08:42,360
 there are, for instance, SMOC.

1272
01:08:42,360 --> 01:08:43,880
 It's actually pretty dated now.

1273
01:08:43,880 --> 01:08:45,800
 People still use it, though.

1274
01:08:45,800 --> 01:08:47,880
 This is a state machine.

1275
01:08:47,880 --> 01:08:50,800
 Right in Ross, people have state machine toolboxes and the like.

1276
01:08:50,800 --> 01:08:58,840
 If you look at the individual skills and the disloading

1277
01:08:58,840 --> 01:09:00,600
 task--

1278
01:09:00,600 --> 01:09:02,720
 I should run that again as I say it--

1279
01:09:02,720 --> 01:09:04,600
 there was a simple state machine there.

1280
01:09:04,600 --> 01:09:06,200
 It was actually written in a way that

1281
01:09:06,200 --> 01:09:09,200
 was kind of a mix of procedural logic and state machine logic.

1282
01:09:09,200 --> 01:09:13,480
 But it's even non-trivial every time you pick up a mug.

1283
01:09:13,480 --> 01:09:15,080
 You approach.

1284
01:09:15,080 --> 01:09:17,120
 You see that little visual servoing?

1285
01:09:17,120 --> 01:09:17,800
 That's ICP.

1286
01:09:17,800 --> 01:09:19,480
 Remember I told you about that before?

1287
01:09:19,480 --> 01:09:21,120
 It does a little ICP.

1288
01:09:21,120 --> 01:09:22,740
 I thought the mug was going to be here.

1289
01:09:22,740 --> 01:09:25,880
 I'm going to use my hand cameras to adjust it.

1290
01:09:25,880 --> 01:09:28,680
 And then I'm going to insert to grasp, retract,

1291
01:09:28,680 --> 01:09:32,520
 move to my pre-place, all the stuff we're doing here.

1292
01:09:32,520 --> 01:09:35,480
 And that was done at the low level control

1293
01:09:35,480 --> 01:09:39,640
 for the disloading demo.

1294
01:09:39,640 --> 01:09:43,320
 My favorite one, actually, that programmed a really rich

1295
01:09:43,320 --> 01:09:46,640
 behavior was when it picked up plates.

1296
01:09:46,640 --> 01:09:50,040
 So this is the sim.

1297
01:09:50,040 --> 01:09:51,920
 Obviously, this is real.

1298
01:09:51,920 --> 01:09:54,480
 That was a pretty complicated maneuver

1299
01:09:54,480 --> 01:09:56,480
 to get this big hand with a big robot

1300
01:09:56,480 --> 01:10:00,120
 to reliably pick up plates like that.

1301
01:10:00,120 --> 01:10:02,680
 And it was coded with the same sort of logic,

1302
01:10:02,680 --> 01:10:06,880
 where it would be a kind of-- the way we had it authored

1303
01:10:06,880 --> 01:10:09,280
 in code was a kind of a mix of procedural and state machine

1304
01:10:09,280 --> 01:10:12,560
 logic, but a simple script.

1305
01:10:12,560 --> 01:10:13,880
 It's kind of what you'd expect.

1306
01:10:13,880 --> 01:10:16,700
 And the art is in picking the parameters

1307
01:10:16,700 --> 01:10:18,840
 of these little transitions and the like,

1308
01:10:18,840 --> 01:10:21,200
 but the script is exactly what anybody would write down,

1309
01:10:21,200 --> 01:10:22,000
 pretty much.

1310
01:10:22,000 --> 01:10:29,600
 So for instance, I asked Siwan, who wrote this, to describe it.

1311
01:10:29,600 --> 01:10:30,400
 And he's funny.

1312
01:10:30,400 --> 01:10:34,680
 He's like, you kind of scooped the gripper into a solid grasp.

1313
01:10:34,680 --> 01:10:39,360
 And these are terminated with sensor-based feedback.

1314
01:10:39,360 --> 01:10:43,000
 So it would kind of scoop up until it felt collision

1315
01:10:43,000 --> 01:10:46,720
 with the hand in the palm.

1316
01:10:46,720 --> 01:10:49,440
 And then it would stop that and transition to the next thing.

1317
01:10:49,440 --> 01:10:50,840
 But these state machines are real.

1318
01:10:50,840 --> 01:10:53,240
 And they allow you to program pretty complicated things.

1319
01:10:53,240 --> 01:10:58,200
 Those couple examples were all at the sort of low level.

1320
01:10:58,200 --> 01:11:05,600
 People find that the state machines-- this picture,

1321
01:11:05,600 --> 01:11:09,360
 this view of the world, or the one for your new system,

1322
01:11:09,360 --> 01:11:11,640
 kind of works when you have, I don't know, 10 states

1323
01:11:11,640 --> 01:11:14,360
 or something like that, or a simple structure.

1324
01:11:14,360 --> 01:11:16,440
 Maybe that one's relatively sequential,

1325
01:11:16,440 --> 01:11:20,400
 so you tend to go forward until you break out.

1326
01:11:20,400 --> 01:11:21,840
 But if you get more serious and you

1327
01:11:21,840 --> 01:11:25,200
 try to build a more and more complicated robot out of this,

1328
01:11:25,200 --> 01:11:28,920
 then this paradigm breaks, roughly.

1329
01:11:28,920 --> 01:11:30,920
 It breaks in a couple ways.

1330
01:11:30,920 --> 01:11:34,160
 It just becomes very complicated to author a big diagram

1331
01:11:34,160 --> 01:11:38,040
 and get all of the transitions that you'd want correct.

1332
01:11:38,040 --> 01:11:43,680
 And people found out that it was very hard to write one state

1333
01:11:43,680 --> 01:11:47,440
 machine and take-- you maybe have a subgraph here.

1334
01:11:47,440 --> 01:11:49,480
 You think, I'd really love to take that subgraph

1335
01:11:49,480 --> 01:11:51,520
 and use it in a slightly different application,

1336
01:11:51,520 --> 01:11:54,680
 have a modular sense in the state machines.

1337
01:11:54,680 --> 01:11:56,920
 And something about the state machine architecture,

1338
01:11:56,920 --> 01:11:59,040
 people decided it was very hard to do that.

1339
01:11:59,040 --> 01:12:02,120
 It's very hard to take a piece and use it.

1340
01:12:02,120 --> 01:12:04,280
 Because you have to sever all the edges coming in.

1341
01:12:04,280 --> 01:12:06,360
 And that changes the behavior of the state machine.

1342
01:12:06,360 --> 01:12:08,560
 And then you have to rewire it to all the new places.

1343
01:12:08,560 --> 01:12:13,840
 And that is so delicate that it was very hard to do that.

1344
01:12:13,840 --> 01:12:18,800
 So the different machinery that people have authored,

1345
01:12:18,800 --> 01:12:21,560
 this actually came from the computer games world.

1346
01:12:21,560 --> 01:12:24,600
 This is like gamers were writing big state machines

1347
01:12:24,600 --> 01:12:28,440
 to make their Unreal games and the like.

1348
01:12:28,440 --> 01:12:31,560
 And it just broke.

1349
01:12:31,560 --> 01:12:33,520
 And so they invented a new paradigm

1350
01:12:33,520 --> 01:12:39,160
 called behavior trees, which are very state machine-like.

1351
01:12:39,160 --> 01:12:41,480
 Since it's late, I won't talk about the details here.

1352
01:12:41,480 --> 01:12:43,840
 We have a problem that will help you think through it.

1353
01:12:43,840 --> 01:12:46,400
 But it's another programming paradigm that's similar to this.

1354
01:12:46,400 --> 01:12:50,240
 But the computation is organized a little bit differently.

1355
01:12:50,240 --> 01:12:55,080
 At every time step, you run through the behavior tree.

1356
01:12:55,080 --> 01:12:56,800
 And they can tell you whether you're done

1357
01:12:56,800 --> 01:12:57,880
 and you should stop, or whether you should

1358
01:12:57,880 --> 01:12:59,040
 continue on to the next one.

1359
01:12:59,040 --> 01:13:03,240
 Each of these nodes has a little bit of programming logic.

1360
01:13:03,240 --> 01:13:08,560
 And the consensus has been that this slightly different

1361
01:13:08,560 --> 01:13:13,760
 programming paradigm allows you to write much bigger machines

1362
01:13:13,760 --> 01:13:16,960
 that are much more modular, where people will frequently

1363
01:13:16,960 --> 01:13:19,560
 take their behavior tree, a big chunk out of this behavior tree

1364
01:13:19,560 --> 01:13:20,760
 and stick it in another behavior tree

1365
01:13:20,760 --> 01:13:22,560
 and immediately be happy with the behavior.

1366
01:13:22,560 --> 01:13:34,200
 It really does come out of gaming.

1367
01:13:34,200 --> 01:13:35,160
 That's where it started.

1368
01:13:35,160 --> 01:13:36,320
 But roboticists use it too.

1369
01:13:36,320 --> 01:13:41,620
 In fact, to prove that, I found another reference

1370
01:13:41,620 --> 01:13:45,800
 to the ROS behavior tree package.

1371
01:13:45,800 --> 01:13:48,160
 This is PyTrees ROS.

1372
01:13:48,160 --> 01:13:52,880
 And it's actually a really nicely architected software

1373
01:13:52,880 --> 01:13:55,640
 package.

1374
01:13:55,640 --> 01:13:57,720
 And you can make a behavior tree fit in the same way

1375
01:13:57,720 --> 01:13:58,480
 we did a state machine.

1376
01:13:58,480 --> 01:13:59,920
 That could be a system that's reasoning

1377
01:13:59,920 --> 01:14:02,280
 about all the discrete logic and making-- that fits right

1378
01:14:02,280 --> 01:14:03,640
 into the system's framework.

1379
01:14:03,640 --> 01:14:05,440
 I haven't made it easy for you to do that.

1380
01:14:05,440 --> 01:14:09,200
 And so again, at the very end, I'll ask just--

1381
01:14:09,200 --> 01:14:11,520
 or over time as you think about it,

1382
01:14:11,520 --> 01:14:13,760
 I could try to make some of these things easier to do.

1383
01:14:13,760 --> 01:14:22,400
 But OK, I'm sorry that I'm just going to keep going

1384
01:14:22,400 --> 01:14:24,560
 a little bit since I won't do the stretch right now.

1385
01:14:24,560 --> 01:14:31,560
 So the interesting thing is that a lot of the state machine

1386
01:14:31,560 --> 01:14:34,720
 and even the behavior trees, they

1387
01:14:34,720 --> 01:14:41,480
 get you to a certain place, but oftentimes people need more.

1388
01:14:41,480 --> 01:14:43,480
 And the reason you tend to need more

1389
01:14:43,480 --> 01:14:47,400
 is if you have some very long term planning required.

1390
01:14:47,400 --> 01:14:49,160
 If there are consequences of your actions

1391
01:14:49,160 --> 01:14:51,760
 now that need to be sequenced in a certain order

1392
01:14:51,760 --> 01:14:53,280
 to achieve a long term goal.

1393
01:14:53,280 --> 01:14:56,840
 Like maybe I need to have all the mugs in the top shelf

1394
01:14:56,840 --> 01:15:00,600
 in order to accomplish my dish loading.

1395
01:15:00,600 --> 01:15:04,360
 And that takes it to a different paradigm, which

1396
01:15:04,360 --> 01:15:06,880
 is the planning paradigm, where you

1397
01:15:06,880 --> 01:15:09,160
 tend to take these low level skills

1398
01:15:09,160 --> 01:15:12,760
 and combine them into some sort of a skill framework.

1399
01:15:12,760 --> 01:15:15,360
 And we'll work on skills and motion planning

1400
01:15:15,360 --> 01:15:16,640
 a lot going forward.

1401
01:15:16,640 --> 01:15:19,840
 But I want to foreshadow that here

1402
01:15:19,840 --> 01:15:24,000
 with just thinking about how it's related to state machines.

1403
01:15:24,000 --> 01:15:28,200
 So for the dish loading example, there

1404
01:15:28,200 --> 01:15:30,040
 were a bunch of skills like pushing things out

1405
01:15:30,040 --> 01:15:34,080
 of the corner, picking up mugs, picking up silverware.

1406
01:15:34,080 --> 01:15:36,720
 These were all authored as different skills.

1407
01:15:36,720 --> 01:15:41,320
 And then rather than write down one time some big automaton,

1408
01:15:41,320 --> 01:15:45,920
 or some big state machine, we would

1409
01:15:45,920 --> 01:15:49,600
 define the rules of interaction and use a planner

1410
01:15:49,600 --> 01:15:53,760
 to decide what the action was on every time step.

1411
01:15:53,760 --> 01:15:54,440
 OK.

1412
01:15:54,440 --> 01:15:57,280
 And that's got a long history in AI.

1413
01:15:57,280 --> 01:16:03,360
 Strips is the original name of it, this planning architecture,

1414
01:16:03,360 --> 01:16:06,160
 where you just say, I've got an initial state, I've got a goal.

1415
01:16:06,160 --> 01:16:09,720
 And basically, think of it as doing graph search

1416
01:16:09,720 --> 01:16:12,600
 on a discrete graph, saying I'm going to do this action, then

1417
01:16:12,600 --> 01:16:14,400
 this action, and then this action, in order

1418
01:16:14,400 --> 01:16:17,840
 to accomplish a long term goal.

1419
01:16:17,840 --> 01:16:20,320
 You have an initial state, a goal state,

1420
01:16:20,320 --> 01:16:24,640
 and a set of actions where those actions are authored

1421
01:16:24,640 --> 01:16:26,840
 as I have a potential edge, saying

1422
01:16:26,840 --> 01:16:29,600
 based on what conditions must be satisfied for me

1423
01:16:29,600 --> 01:16:32,440
 to write to do a pick x, and then what conditions

1424
01:16:32,440 --> 01:16:35,000
 will be satisfied if I do pick x for a while.

1425
01:16:35,000 --> 01:16:43,600
 And strips is the old version.

1426
01:16:43,600 --> 01:16:46,680
 Padiddle, the planning domain definition language,

1427
01:16:46,680 --> 01:16:50,000
 is the newer, richer language of these things.

1428
01:16:50,000 --> 01:16:58,240
 I could tell-- I'll just move past the details of that.

1429
01:16:58,240 --> 01:16:59,960
 But I think it's super interesting to look

1430
01:16:59,960 --> 01:17:03,080
 at how this worked in the specific application

1431
01:17:03,080 --> 01:17:05,440
 of the dish loading.

1432
01:17:05,440 --> 01:17:11,800
 So we had our skill concept, our action primitive,

1433
01:17:11,800 --> 01:17:14,360
 which basically you had to-- in order to write an action

1434
01:17:14,360 --> 01:17:16,880
 primitive in the framework, you had to basically say,

1435
01:17:16,880 --> 01:17:21,760
 given the current state, could I run my skill right now?

1436
01:17:21,760 --> 01:17:23,280
 Yes or no.

1437
01:17:23,280 --> 01:17:26,920
 And if I were to run that skill, what would be the new state?

1438
01:17:27,920 --> 01:17:33,160
 And that's pretty much it.

1439
01:17:33,160 --> 01:17:37,280
 And the skills that we did, the actions that we implemented,

1440
01:17:37,280 --> 01:17:39,720
 were-- this is the entire list.

1441
01:17:39,720 --> 01:17:41,640
 Open dishwasher door, close dishwasher door,

1442
01:17:41,640 --> 01:17:42,340
 start dishwasher.

1443
01:17:42,340 --> 01:17:44,400
 That was pretty funny.

1444
01:17:44,400 --> 01:17:48,000
 It wasn't actually plugged in, because we

1445
01:17:48,000 --> 01:17:49,840
 weren't allowed to run water to the lab

1446
01:17:49,840 --> 01:17:52,040
 in that particular way, which is probably a good idea

1447
01:17:52,040 --> 01:17:53,600
 in retrospect.

1448
01:17:53,600 --> 01:17:56,240
 But the robot, we built a whole skill

1449
01:17:56,240 --> 01:17:58,520
 with a capacitive sensor, because it

1450
01:17:58,520 --> 01:18:01,280
 was a smart dishwasher.

1451
01:18:01,280 --> 01:18:04,480
 So you needed to put one of your stylists

1452
01:18:04,480 --> 01:18:09,440
 from your standard stylus to make a capacitive sensor work.

1453
01:18:09,440 --> 01:18:11,200
 And we mounted it on the back of the EWA.

1454
01:18:11,200 --> 01:18:13,120
 And we had a skill that would just go and boop.

1455
01:18:13,120 --> 01:18:14,960
 And the dishwasher would go doo-doo-doo-dee.

1456
01:18:14,960 --> 01:18:15,920
 And we were good.

1457
01:18:15,920 --> 01:18:16,420
 Yes?

1458
01:18:16,420 --> 01:18:18,360
 What's the optimistic part?

1459
01:18:18,360 --> 01:18:19,640
 Optimistic program.

1460
01:18:19,640 --> 01:18:21,840
 Yeah, right.

1461
01:18:21,840 --> 01:18:24,120
 Is there a pessimistic one, too?

1462
01:18:24,120 --> 01:18:26,000
 Just program.

1463
01:18:26,000 --> 01:18:26,800
 Yeah.

1464
01:18:26,800 --> 01:18:29,240
 So my guess is-- I actually don't know.

1465
01:18:29,240 --> 01:18:30,640
 I would go look.

1466
01:18:30,640 --> 01:18:33,720
 But it's possible to get unjammed

1467
01:18:33,720 --> 01:18:36,160
 by these kind of things.

1468
01:18:36,160 --> 01:18:39,440
 There was an aggressive version that was more optimistic.

1469
01:18:39,440 --> 01:18:40,280
 That's pretty funny.

1470
01:18:40,280 --> 01:18:42,160
 I copied the list, but I didn't actually

1471
01:18:42,160 --> 01:18:43,320
 look at that one carefully.

1472
01:18:43,320 --> 01:18:47,460
 Yes?

1473
01:18:47,460 --> 01:18:49,040
 So there's no learning so far, right?

1474
01:18:49,040 --> 01:18:50,480
 It's fully planned.

1475
01:18:50,480 --> 01:18:51,360
 Exactly.

1476
01:18:51,360 --> 01:18:52,240
 That's a great point.

1477
01:18:52,240 --> 01:18:53,360
 There's no learning so far.

1478
01:18:53,360 --> 01:18:55,320
 And I think that's-- my last slides are like,

1479
01:18:55,320 --> 01:18:56,600
 how do you put learning into this?

1480
01:18:56,600 --> 01:18:57,960
 But this is not learning so far.

1481
01:18:57,960 --> 01:18:59,440
 Second question.

1482
01:18:59,440 --> 01:19:01,400
 How do we evaluate the goal?

1483
01:19:01,400 --> 01:19:03,400
 Because for example, if you have a dishwasher

1484
01:19:03,400 --> 01:19:06,280
 and you want to put a mug into the sticky thing

1485
01:19:06,280 --> 01:19:09,200
 in the dishwasher, and for some reason

1486
01:19:09,200 --> 01:19:12,200
 it drops out after you put it-- so you have actually

1487
01:19:12,200 --> 01:19:14,160
 to go to cheat and put it all out.

1488
01:19:14,160 --> 01:19:16,600
 But then, like, the door is the whole space,

1489
01:19:16,600 --> 01:19:18,680
 so you kind of put watermarks there.

1490
01:19:18,680 --> 01:19:20,600
 It's a hard problem.

1491
01:19:20,600 --> 01:19:22,880
 So yes, in the limitations of this,

1492
01:19:22,880 --> 01:19:24,920
 one of the big limitations is that you

1493
01:19:24,920 --> 01:19:30,280
 need to define a state, a symbolic state of the world.

1494
01:19:30,280 --> 01:19:32,040
 And I'll put this on a slide in a minute.

1495
01:19:32,040 --> 01:19:35,800
 And you need to somehow have the perception system tell you

1496
01:19:35,800 --> 01:19:38,320
 what the state is and have a model for how

1497
01:19:38,320 --> 01:19:39,880
 that state's going to evolve.

1498
01:19:39,880 --> 01:19:41,880
 And that is a really hard thing to do.

1499
01:19:41,880 --> 01:19:44,440
 And it's a limitation of the framework.

1500
01:19:44,440 --> 01:19:48,600
 So goals are typically authored in a logical way,

1501
01:19:48,600 --> 01:19:51,000
 but they are often impoverished because of all the things

1502
01:19:51,000 --> 01:19:54,440
 that can happen in the world.

1503
01:19:54,440 --> 01:19:57,360
 The dishwasher state was things like,

1504
01:19:57,360 --> 01:19:59,200
 are the clean items put away?

1505
01:19:59,200 --> 01:20:01,000
 The number of clean items put away,

1506
01:20:01,000 --> 01:20:03,000
 the number of dirty items available.

1507
01:20:03,000 --> 01:20:06,280
 It's a very discrete state that summarizes

1508
01:20:06,280 --> 01:20:09,800
 what the robot perceived in the sink.

1509
01:20:09,800 --> 01:20:16,160
 And that's all right out of the code.

1510
01:20:16,160 --> 01:20:19,200
 But if you take those discrete logic

1511
01:20:19,200 --> 01:20:21,760
 and author yourself a bunch of skills,

1512
01:20:21,760 --> 01:20:24,040
 then you can do a little planning on the fly

1513
01:20:24,040 --> 01:20:26,280
 and get all the robustness that you see.

1514
01:20:26,280 --> 01:20:29,400
 So this is like the example of someone

1515
01:20:29,400 --> 01:20:31,920
 went and closed the dishwasher rack

1516
01:20:31,920 --> 01:20:33,240
 and they had to set the mug down.

1517
01:20:33,240 --> 01:20:35,040
 That's exactly what it was.

1518
01:20:35,040 --> 01:20:37,000
 The robustness here made us susceptible

1519
01:20:37,000 --> 01:20:40,600
 to the crazy, noisy racks.

1520
01:20:40,600 --> 01:20:42,920
 So Boston Dynamics, they kick the robot.

1521
01:20:42,920 --> 01:20:44,380
 But we just closed the dishwasher.

1522
01:20:44,380 --> 01:20:49,400
 We could have kicked the dishwasher, I guess.

1523
01:20:52,840 --> 01:20:55,640
 But this time, instead of a state machine

1524
01:20:55,640 --> 01:20:57,640
 making that robustness, it's a planner

1525
01:20:57,640 --> 01:20:59,400
 that makes that robustness.

1526
01:20:59,400 --> 01:21:01,640
 You just say, these are the actions I can do.

1527
01:21:01,640 --> 01:21:03,020
 This is when I'm allowed to do it

1528
01:21:03,020 --> 01:21:04,680
 and what the outcomes are going to be.

1529
01:21:04,680 --> 01:21:07,920
 And I roughly do a graph search, a richer version of graph search

1530
01:21:07,920 --> 01:21:09,920
 to make that happen.

1531
01:21:09,920 --> 01:21:13,280
 And you can get the same levels of robustness out.

1532
01:21:13,280 --> 01:21:15,200
 This is exactly what you were asking.

1533
01:21:15,200 --> 01:21:17,200
 The problem with this approach, the limitation

1534
01:21:17,200 --> 01:21:19,480
 of this approach, is that it requires somehow

1535
01:21:19,480 --> 01:21:21,720
 to take those discrete states and acquire them

1536
01:21:21,720 --> 01:21:24,240
 from perception.

1537
01:21:24,240 --> 01:21:25,840
 And you have to have a model of how

1538
01:21:25,840 --> 01:21:28,640
 that state is going to evolve if I apply certain actions.

1539
01:21:28,640 --> 01:21:32,840
 And these can be very brittle in the real world.

1540
01:21:32,840 --> 01:21:36,240
 So there's been famous debates about this.

1541
01:21:36,240 --> 01:21:39,480
 And one of the most famous, maybe,

1542
01:21:39,480 --> 01:21:41,360
 was Rod Brooks, who wrote a nice paper called

1543
01:21:41,360 --> 01:21:46,720
 "Elephants Don't Play Chess," arguing against intelligence

1544
01:21:46,720 --> 01:21:47,560
 without reason.

1545
01:21:47,560 --> 01:21:49,760
 But there was a line of arguments

1546
01:21:49,760 --> 01:21:52,640
 that he made basically saying the AI community is going down

1547
01:21:52,640 --> 01:21:55,640
 the wrong direction by trying to summarize the world

1548
01:21:55,640 --> 01:21:57,000
 with symbolic states.

1549
01:21:57,000 --> 01:21:58,760
 It's just too hard.

1550
01:21:58,760 --> 01:22:00,520
 Elephants don't play chess.

1551
01:22:00,520 --> 01:22:03,480
 They don't do planning like this on every time step.

1552
01:22:03,480 --> 01:22:05,920
 That's the chess analogy.

1553
01:22:05,920 --> 01:22:08,600
 And when he was saying this, it was right before he went off

1554
01:22:08,600 --> 01:22:12,600
 and started iRobot and made Roomba,

1555
01:22:12,600 --> 01:22:15,280
 which was highly successful without playing chess,

1556
01:22:15,280 --> 01:22:16,880
 with just kind of bumping around.

1557
01:22:16,880 --> 01:22:20,560
 And you know how it did that, the Roomba application,

1558
01:22:20,560 --> 01:22:22,160
 initially at least.

1559
01:22:22,160 --> 01:22:23,680
 It's probably evolved now.

1560
01:22:23,680 --> 01:22:27,320
 But it was basically-- Rod's version of it

1561
01:22:27,320 --> 01:22:29,120
 was called the subsumption architecture.

1562
01:22:29,120 --> 01:22:32,580
 But it was the precursor to behavior trees.

1563
01:22:32,580 --> 01:22:34,680
 Roomba was much more like a behavior tree.

1564
01:22:34,680 --> 01:22:38,200
 And it was saying, don't rely on planners.

1565
01:22:38,200 --> 01:22:41,240
 It's too brittle for the real world.

1566
01:22:41,240 --> 01:22:44,440
 Symbols whose grounding in physical reality

1567
01:22:44,440 --> 01:22:46,760
 has rarely been achieved, says Rod.

1568
01:22:46,760 --> 01:22:53,440
 And then I'll just end saying that I do think

1569
01:22:53,440 --> 01:22:56,040
 one of the new challenges-- and you'll see lots of papers

1570
01:22:56,040 --> 01:22:57,280
 about this right now--

1571
01:22:57,280 --> 01:23:00,720
 is how do I make this sort of skills framework,

1572
01:23:00,720 --> 01:23:05,560
 long-term decision making, work when those skills are learned?

1573
01:23:05,560 --> 01:23:10,200
 Where now, the way people are picking up plates at TRI now

1574
01:23:10,200 --> 01:23:14,600
 is with policies, controllers, that

1575
01:23:14,600 --> 01:23:18,200
 were acquired by learning.

1576
01:23:18,200 --> 01:23:22,560
 And we have demonstrations that are much more robust.

1577
01:23:22,560 --> 01:23:25,200
 Perception failures and other things like this now,

1578
01:23:25,200 --> 01:23:27,280
 they can pick up plates very robustly coming out

1579
01:23:27,280 --> 01:23:28,800
 of machine learning.

1580
01:23:28,800 --> 01:23:31,360
 And the question is, if I want to put that

1581
01:23:31,360 --> 01:23:34,640
 into a skills type framework so a high level task planner can

1582
01:23:34,640 --> 01:23:36,840
 reason about it, or write a state machine about it,

1583
01:23:36,840 --> 01:23:40,320
 or whatever, how do you combine the new tools from learning

1584
01:23:40,320 --> 01:23:42,680
 with the classic tools from planning?

1585
01:23:42,680 --> 01:23:46,720
 And that's a big topic we'll talk more about.

1586
01:23:46,720 --> 01:23:49,040
 Good, the last thing I'll say is that we're

1587
01:23:49,040 --> 01:23:51,320
 making the-- because you have your project proposal next

1588
01:23:51,320 --> 01:23:53,800
 week, the PSAT will be a little smaller this time

1589
01:23:53,800 --> 01:23:54,960
 to accommodate.

1590
01:23:54,960 --> 01:23:58,440
 But please, again, ask us about project proposals

1591
01:23:58,440 --> 01:24:02,440
 and use the pre-proposals as a chance to get good feedback.

1592
01:24:02,440 --> 01:24:02,940
 OK, thanks.

1593
01:24:06,240 --> 01:24:07,240
 [INAUDIBLE]

1594
01:24:08,240 --> 01:24:08,740
 Oh.

1595
01:24:08,740 --> 01:24:09,240
 [INAUDIBLE]

1596
01:24:09,240 --> 01:24:10,240
 [INAUDIBLE]

1597
01:24:11,240 --> 01:24:11,740
 [INAUDIBLE]

1598
01:24:12,740 --> 01:24:15,740
 In particular, if you switch from under-preparedness

1599
01:24:15,740 --> 01:24:18,740
 to preparedness, how do you do that?

1600
01:24:18,740 --> 01:24:22,080
 [SIDE CONVERSATION]

1601
01:24:22,080 --> 01:24:32,080
 [BLANK_AUDIO]

